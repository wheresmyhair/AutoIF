{"id": 0, "instruction": "Answer with words that begin with the letter 'B'", "eval_func": [["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if not word.startswith('B'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.strip().split()\n    if not words:\n        return False\n    for word in words:\n        if not word.startswith('B'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    return bool(words) and all(word.startswith('B') for word in words)", 1.0]], "cases": [["Bees but", false], ["Beetlejuice Biscuit", true], ["banana", false], ["B", true], ["Banana", true], ["B B", true], ["Butterfly Balloon", true], ["Bread butter", false], ["", false], ["Big car", false], ["Blue Berry", true]]}
{"id": 1, "instruction": "Construct the reply as if it's a telegram STOP", "eval_func": [["def evaluate(response):\n    original_stripped = response.strip()\n    if not original_stripped.endswith('STOP'):\n        return False\n    if original_stripped.upper() != original_stripped:\n        return False\n    return True", 1.0]], "cases": [["MEETING.STOP", true], ["Arriving tomorrow STOP", false], ["ARRIVING TOMORROW STOP", true], ["MEETING CANCELED", false]]}
{"id": 3, "instruction": "Incorporate a famous movie quote seamlessly into your answer", "eval_func": [["def evaluate(response):\n    famous_quotes = [\n        \"may the force be with you\",\n        \"life is like a box of chocolates\",\n        \"here's looking at you, kid\",\n        \"you can't handle the truth\",\n        \"i'll be back\",\n        \"e.t. phone home\",\n        \"there's no place like home\",\n        \"why so serious?\",\n        \"my precious\",\n        \"houston, we have a problem\",\n        \"you talking to me?\",\n        \"i'm king of the world\",\n        \"show me the money\",\n        \"you had me at hello\",\n        \"to infinity and beyond\",\n        \"great scott\",\n        \"i see dead people\",\n        \"they call it a royale with cheese\",\n        \"say hello to my little friend\",\n        \"i feel the need—the need for speed\",\n        \"hasta la vista, baby\",\n        \"you're gonna need a bigger boat\",\n        \"my mama always said life was like a box of chocolates\",\n        \"keep your friends close, but your enemies closer\",\n        \"i am your father\"\n    ]\n    response_lower = response.lower()\n    for quote in famous_quotes:\n        if quote in response_lower:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    famous_quotes = [\n        \"may the force be with you\",\n        \"here's looking at you, kid\",\n        \"you can't handle the truth\",\n        \"i'll be back\",\n        \"life is like a box of chocolates\",\n        \"houston, we have a problem\",\n        \"why so serious\",\n        \"i'm king of the world\",\n        \"you talking to me\",\n        \"keep your friends close, but your enemies closer\",\n        \"there's no place like home\",\n        \"i see dead people\",\n        \"e.t. phone home\",\n        \"my precious\",\n        \"i feel the need—the need for speed\",\n        \"to infinity and beyond\",\n        \"you're gonna need a bigger boat\",\n        \"i am your father\",\n        \"hasta la vista, baby\",\n        \"you had me at hello\"\n    ]\n    response_lower = response.lower()\n    for quote in famous_quotes:\n        if quote in response_lower:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    famous_quotes = [\n        \"may the force be with you\",\n        \"here's looking at you, kid\",\n        \"you can't handle the truth\",\n        \"i'll be back\",\n        \"life is like a box of chocolates\",\n        \"my precious\",\n        \"houston, we have a problem\",\n        \"why so serious\",\n        \"i'm king of the world\",\n        \"you talking to me\",\n        \"there's no place like home\",\n        \"to infinity and beyond\",\n        \"you had me at hello\",\n        \"keep your friends close, but your enemies closer\",\n        \"i see dead people\",\n        \"show me the money\",\n        \"you're gonna need a bigger boat\",\n        \"hasta la vista, baby\",\n        \"nobody puts baby in a corner\",\n        \"i feel the need—the need for speed\",\n    ]\n    lower_response = response.lower()\n    for quote in famous_quotes:\n        if quote in lower_response:\n            return True\n    return False", 1.0], ["import re\ndef evaluate(response):\n    famous_quotes = [\n        \"May the Force be with you.\",\n        \"I'll be back.\",\n        \"Here's looking at you, kid.\",\n        \"You can't handle the truth!\",\n        \"Life is like a box of chocolates.\",\n        \"My precious.\",\n        \"Hasta la vista, baby.\",\n        \"E.T. phone home.\",\n        \"Show me the money!\",\n        \"Why so serious?\",\n        \"I'm king of the world!\",\n        \"There's no place like home.\",\n        \"To infinity and beyond!\",\n        \"Here's Johnny!\",\n        \"I am your father.\"\n    ]\n\n    processed_response = re.sub(r'[^\\w\\s\\']', '', response.lower())\n    processed_response = re.sub(r'\\s+', ' ', processed_response).strip()\n\n    for quote in famous_quotes:\n        processed_quote = re.sub(r'[^\\w\\s\\']', '', quote.lower())\n        processed_quote = re.sub(r'\\s+', ' ', processed_quote).strip()\n        if processed_quote in processed_response:\n            return True\n    return False", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    famous_quotes = [\n        \"may the force be with you\",\n        \"here's looking at you kid\",\n        \"you can't handle the truth\",\n        \"i'll be back\",\n        \"life is like a box of chocolates\",\n        \"you talking to me\",\n        \"go ahead make my day\",\n        \"there's no place like home\",\n        \"why so serious\",\n        \"i am your father\",\n        \"houston we have a problem\",\n        \"my precious\",\n        \"i see dead people\",\n        \"show me the money\",\n        \"you had me at hello\",\n        \"keep your friends close but your enemies closer\",\n        \"et phone home\",\n        \"i feel the need the need for speed\",\n        \"to infinity and beyond\",\n        \"nobody puts baby in a corner\"\n    ]\n    \n    processed = re.sub(r\"[^\\w\\s']\", ' ', response.lower())\n    processed = re.sub(r\"\\s+\", ' ', processed).strip()\n    \n    for quote in famous_quotes:\n        if quote in processed:\n            return True\n    return False", 0.8888888888888888]], "cases": [["The best advice I can give is, 'May the Force be with you.' It works every time.", true], ["This answer contains no references to cinema.", false], ["This is a straightforward response without any film references.", false], ["Life is like a box of chocolates; you never know what you'll get.", true], ["He yelled 'Hasta la vista, baby!' before leaving.", true], ["This is a test response with no movie quotes.", false], ["He whispered, 'Life is like a box of chocolates, my friend,' and smiled.", true], ["As they say, May the Force be with you in all your endeavors.", true], ["When in doubt, remember: 'You talking to me?' That's a classic line.", true]]}
{"id": 6, "instruction": "Use only onomatopoeia", "eval_func": [["def evaluate(response):\n    onomatopoeia_words = {'bang', 'boom', 'crash', 'clang', 'buzz', 'hiss', 'meow', 'woof', 'moo', 'oink', 'quack', 'tweet', 'splash', 'drip', 'click', 'clap', 'snap', 'crack', 'pop', 'zap', 'ding', 'ping', 'beep', 'vroom', 'pow', 'wham', 'thud', 'growl', 'purr', 'howl', 'screech', 'sizzle', 'fizz', 'clink', 'jingle', 'rustle', 'gurgle', 'plop', 'slurp', 'neigh', 'roar', 'chirp', 'ribbit', 'hee-haw', 'tick', 'tock', 'knock', 'clatter', 'thump', 'whack', 'zoom', 'ring', 'honk', 'murmur', 'cuckoo', 'splat', 'squeak', 'rumble', 'giggle', 'hum', 'blare', 'clank', 'creak', 'flutter', 'gargle', 'hush', 'plink', 'rat', 'tat', 'smash', 'snort', 'squish', 'thwack', 'twang', 'wheeze', 'yowl', 'zzing'}\n    import re\n    words = re.findall(r\"[\\w'-]+\", response.lower())\n    for word in words:\n        parts = word.replace(\"'\", '').split('-')\n        for part in parts:\n            if part not in onomatopoeia_words:\n                return False\n    return True", 0.9285714285714286], ["import re\n\ndef evaluate(response):\n    onomatopoeia = {'achoo', 'bang', 'boom', 'clap', 'clang', 'crack', 'crash', 'ding', 'dong', 'fizz', 'hiss', 'meow', 'moo', 'oink', 'pop', 'pow', 'roar', 'splash', 'tick', 'tock', 'tweet', 'vroom', 'woof', 'zoom', 'beep', 'buzz', 'chirp', 'click', 'clink', 'cuckoo', 'drip', 'growl', 'honk', 'howl', 'hum', 'knock', 'murmur', 'ping', 'pitter-patter', 'purr', 'ring', 'rumble', 'rustle', 'screech', 'sizzle', 'slap', 'snap', 'splat', 'squelch', 'thud', 'tic-toc', 'whack', 'wham', 'whimper', 'whirr', 'whistle', 'zap'}\n    words = response.split()\n    for word in words:\n        processed = re.sub(r'[^a-zA-Z-]', '', word).lower()\n        if not processed or processed not in onomatopoeia:\n            return False\n    return bool(words)", 0.8571428571428571], ["import re\n\ndef evaluate(response):\n    onomatopoeia = {\n        'bang', 'boom', 'crash', 'zap', 'ding', 'buzz', 'clang', 'clap',\n        'click', 'crack', 'pop', 'hiss', 'meow', 'moo', 'oink', 'quack',\n        'ribbit', 'roar', 'screech', 'splash', 'thud', 'tick', 'tock',\n        'vroom', 'wham', 'woof', 'zoom', 'pow', 'snap', 'growl', 'howl',\n        'purr', 'sizzle', 'slurp', 'splat', 'squeak', 'thump', 'twang',\n        'whack', 'whisk', 'zip', 'beep', 'honk', 'clink', 'giggle', 'murmur'\n    }\n    words = re.findall(r'[a-zA-Z]+', response.lower())\n    return all(word in onomatopoeia for word in words) if words else False", 0.8571428571428571]], "cases": [["The loud boom", false], ["Boom crash!", true], ["Meow! Woof...", true], ["Meow! Hiss!", true], ["The cat hissed and ran", false], ["Boom crash", true], ["The dog barked loudly", false], ["Ding-Dong", true], ["The cow goes moo", false], ["tick-tock knock", true], ["VROOM zap", true], ["hello there", false], ["bang boom crash", true], ["Boom crash bang", true]]}
{"id": 9, "instruction": "Translate your answer into emojis", "eval_func": [["def evaluate(response):\n    import re\n    if not response:\n        return False\n    emoji_pattern = re.compile(\n        r'^['\n        r'\\U0001F600-\\U0001F64F'\n        r'\\U0001F300-\\U0001F5FF'\n        r'\\U0001F680-\\U0001F6FF'\n        r'\\U0001F1E0-\\U0001F1FF'\n        r'\\U00002500-\\U00002BEF'\n        r'\\U00002702-\\U000027B0'\n        r'\\U000024C2-\\U0001F251'\n        r'\\U0001F900-\\U0001F9FF'\n        r'\\U0001FA70-\\U0001FAFF'\n        r'\\U00002600-\\U000026FF'\n        r'\\U00002700-\\U000027BF'\n        r'\\U0001F200-\\U0001F2FF'\n        r'\\U0001F3FB-\\U0001F3FF'\n        r'\\uFE00-\\uFE0F'\n        r']+$',\n        flags=re.UNICODE\n    )\n    return bool(emoji_pattern.fullmatch(response))", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n    emoji_ranges = [\n        (0x1F600, 0x1F64F),\n        (0x1F300, 0x1F5FF),\n        (0x1F680, 0x1F6FF),\n        (0x1F700, 0x1F77F),\n        (0x1F780, 0x1F7FF),\n        (0x1F800, 0x1F8FF),\n        (0x1F900, 0x1F9FF),\n        (0x2600, 0x26FF),\n        (0x2700, 0x27BF),\n        (0xFE00, 0xFE0F),\n        (0x1F1E6, 0x1F1FF)\n    ]\n    for c in response:\n        code_point = ord(c)\n        in_emoji = False\n        for start, end in emoji_ranges:\n            if start <= code_point <= end:\n                in_emoji = True\n                break\n        if not in_emoji:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n    for char in response:\n        code = ord(char)\n        if not (0x1F600 <= code <= 0x1F64F or\n                0x1F300 <= code <= 0x1F5FF or\n                0x1F680 <= code <= 0x1F6FF or\n                0x1F900 <= code <= 0x1F9FF or\n                0x1FA70 <= code <= 0x1FAFF or\n                0x2600 <= code <= 0x26FF or\n                0x2700 <= code <= 0x27BF or\n                0xFE00 <= code <= 0xFE0F):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    for char in response:\n        code_point = ord(char)\n        if not (\n            (0x1F600 <= code_point <= 0x1F64F) or  # Emoticons\n            (0x1F300 <= code_point <= 0x1F5FF) or  # Misc Symbols and Pictographs\n            (0x1F680 <= code_point <= 0x1F6FF) or  # Transport and Map\n            (0x2600 <= code_point <= 0x26FF) or    # Misc symbols\n            (0x2700 <= code_point <= 0x27BF) or    # Dingbats\n            (0x1F900 <= code_point <= 0x1F9FF) or  # Supplemental Symbols and Pictographs\n            (0x1F1E6 <= code_point <= 0x1F1FF)     # Regional indicators\n        ):\n            return False\n    return bool(response)", 1.0]], "cases": [["👍👋", true], ["🐶🍴", true], ["Hello! 👋", false], ["", false], ["👋🏾", true], ["Dog🐶", false]]}
{"id": 10, "instruction": "Use only the 1000 most common English words", "eval_func": [["import re\n\ndef evaluate(response):\n    allowed_words = {'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take', 'people', 'into', 'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now', 'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two', 'how', 'our', 'work', 'first', 'well', 'way', 'even', 'new', 'want', 'because', 'any', 'these', 'give', 'day', 'most', 'us'}\n    words = re.findall(r'\\b[a-z]+\\b', response.lower())\n    return all(word in allowed_words for word in words)", 0.8888888888888888], ["import string\n\ndef evaluate(response):\n    common_words = {\n        'a', 'able', 'about', 'above', 'accept', 'according', 'account', \n        'across', 'act', 'action', 'activity', 'actually', 'add', 'address', \n        'administration', 'admit', 'adult', 'affect', 'after', 'again', \n        'against', 'age', 'agency', 'ago', 'agree', 'ah', 'air', 'all', \n        'allow', 'almost', 'alone', 'along', 'already', 'also', 'although', \n        'always', 'am', 'america', 'american', 'an', 'analysis', 'and', \n        'animal', 'another', 'answer', 'any', 'anyone', 'anything', 'appear', \n        'apply', 'approach', 'area', 'argue', 'arm', 'around', 'arrive', \n        'art', 'article', 'as', 'ask', 'assume', 'at', 'attack', 'attention', \n        'audience', 'author', 'available', 'avoid', 'away', 'baby', 'back', \n        'bad', 'ball', 'bank', 'bar', 'base', 'be', 'beat', 'beautiful', \n        'because', 'become', 'bed', 'before', 'begin', 'behavior', 'behind', \n        'believe', 'benefit', 'best', 'better', 'between', 'beyond', 'big', \n        'bill', 'billion', 'bit', 'black', 'blood', 'blue', 'board', 'body', \n        'book', 'born', 'both', 'box', 'boy', 'break', 'bring', 'brother', \n        'budget', 'build', 'building', 'business', 'but', 'buy', 'by', 'call', \n        'camera', 'campaign', 'can', 'cancer', 'candidate', 'capital', \n        'car', 'card', 'care', 'career', 'carry', 'case', 'catch', 'cause', \n        'cell', 'center', 'central', 'century', 'certain', 'certainly', \n        'chair', 'challenge', 'chance', 'change', 'character', 'charge', \n        'check', 'child', 'choice', 'choose', 'church', 'citizen', 'city', \n        'civil', 'claim', 'class', 'clear', 'clearly', 'close', 'coach', \n        'cold', 'collection', 'college', 'color', 'come', 'commercial', \n        'common', 'community', 'company', 'compare', 'computer', 'concern', \n        'condition', 'conference', 'congress', 'consider', 'consumer', \n        'contain', 'continue', 'control', 'cost', 'could', 'country', \n        'couple', 'course', 'court', 'cover', 'create', 'crime', 'cultural', \n        'culture', 'cup', 'current', 'cut', 'dark', 'data', 'daughter', \n        'day', 'dead', 'deal', 'death', 'debate', 'decade', 'decide', \n        'decision', 'deep', 'defense', 'degree', 'democrat', 'democratic', \n        'describe', 'design', 'despite', 'detail', 'determine', 'develop', \n        'development', 'die', 'difference', 'different', 'difficult', \n        'dinner', 'direction', 'director', 'discover', 'discuss', 'discussion', \n        'disease', 'do', 'doctor', 'dog', 'door', 'down', 'draw', 'dream', \n        'drive', 'drop', 'drug', 'during', 'each', 'early', 'east', 'easy', \n        'eat', 'economic', 'economy', 'edge', 'education', 'effect', \n        'effort', 'eight', 'either', 'election', 'else', 'employee', 'end', \n        'energy', 'enjoy', 'enough', 'enter', 'entire', 'environment', \n        'environmental', 'especially', 'establish', 'even', 'evening', \n        'event', 'ever', 'every', 'everybody', 'everyone', 'everything', \n        'evidence', 'exactly', 'example', 'executive', 'exist', 'expect', \n        'experience', 'expert', 'explain', 'eye', 'face', 'fact', 'factor', \n        'fail', 'fall', 'family', 'far', 'fast', 'father', 'fear', 'federal', \n        'feel', 'feeling', 'few', 'field', 'fight', 'figure', 'fill', 'film', \n        'final', 'finally', 'financial', 'find', 'fine', 'finger', 'finish', \n        'fire', 'firm', 'first', 'fish', 'five', 'floor', 'fly', 'focus', \n        'follow', 'food', 'foot', 'for', 'force', 'foreign', 'forget', \n        'form', 'former', 'forward', 'four', 'free', 'friend', 'from', \n        'front', 'full', 'fund', 'future', 'game', 'garden', 'gas', \n        'general', 'generation', 'get', 'girl', 'give', 'glass', 'go', \n        'goal', 'good', 'government', 'great', 'green', 'ground', 'group', \n        'grow', 'growth', 'guess', 'gun', 'guy', 'hair', 'half', 'hand', \n        'hang', 'happen', 'happy', 'hard', 'have', 'he', 'head', 'health', \n        'hear', 'heart', 'heat', 'heavy', 'help', 'her', 'here', 'herself', \n        'high', 'him', 'himself', 'his', 'history', 'hit', 'hold', 'home', \n        'hope', 'hospital', 'hot', 'hotel', 'hour', 'house', 'how', 'however', \n        'huge', 'human', 'hundred', 'husband', 'i', 'idea', 'identify', \n        'if', 'image', 'imagine', 'impact', 'important', 'improve', 'in', \n        'include', 'including', 'increase', 'indeed', 'indicate', \n        'individual', 'industry', 'information', 'inside', 'instead', \n        'institution', 'interest', 'interesting', 'international', \n        'interview', 'into', 'investment', 'involve', 'issue', 'it', 'item', \n        'its', 'itself', 'job', 'join', 'just', 'keep', 'key', 'kid', 'kill', \n        'kind', 'kitchen', 'know', 'knowledge', 'land', 'language', 'large', \n        'last', 'late', 'later', 'laugh', 'law', 'lawyer', 'lay', 'lead', \n        'leader', 'learn', 'least', 'leave', 'left', 'leg', 'legal', 'less', \n        'let', 'letter', 'level', 'lie', 'life', 'light', 'like', 'likely', \n        'line', 'list', 'listen', 'little', 'live', 'local', 'long', 'look', \n        'lose', 'loss', 'lot', 'love', 'low', 'machine', 'magazine', 'main', \n        'major', 'majority', 'make', 'man', 'manage', 'management', 'manager', \n        'many', 'market', 'marriage', 'material', 'matter', 'may', 'maybe', \n        'me', 'mean', 'measure', 'media', 'medical', 'meet', 'meeting', \n        'member', 'memory', 'mention', 'message', 'method', 'middle', \n        'might', 'military', 'million', 'mind', 'minute', 'miss', 'model', \n        'modern', 'moment', 'money', 'month', 'more', 'morning', 'most', \n        'mother', 'mouth', 'move', 'movement', 'movie', 'mr', 'mrs', 'much', \n        'music', 'must', 'my', 'myself', 'name', 'nation', 'national', \n        'natural', 'nature', 'near', 'nearly', 'necessary', 'need', 'network', \n        'never', 'new', 'news', 'next', 'nice', 'night', 'no', 'none', \n        'nor', 'north', 'not', 'note', 'nothing', 'notice', 'now', 'n’t', \n        'number', 'occur', 'of', 'off', 'offer', 'office', 'officer', \n        'official', 'often', 'oh', 'oil', 'ok', 'old', 'on', 'once', 'one', \n        'only', 'onto', 'open', 'operation', 'opportunity', 'option', 'or', \n        'order', 'organization', 'other', 'others', 'our', 'out', 'outside', \n        'over', 'own', 'owner', 'page', 'pain', 'painting', 'paper', 'parent', \n        'part', 'participant', 'particular', 'particularly', 'partner', \n        'party', 'pass', 'past', 'patient', 'pattern', 'pay', 'peace', \n        'people', 'per', 'perform', 'performance', 'perhaps', 'period', \n        'person', 'personal', 'phone', 'physical', 'pick', 'picture', 'piece', \n        'place', 'plan', 'plant', 'play', 'player', 'pm', 'point', 'police', \n        'policy', 'political', 'politics', 'poor', 'popular', 'population', \n        'position', 'positive', 'possible', 'power', 'practice', 'prepare', \n        'present', 'president', 'pressure', 'pretty', 'prevent', 'price', \n        'private', 'probably', 'problem', 'process', 'produce', 'product', \n        'production', 'professional', 'professor', 'program', 'project', \n        'property', 'protect', 'prove', 'provide', 'public', 'pull', \n        'purpose', 'push', 'put', 'quality', 'question', 'quickly', 'quite', \n        'race', 'radio', 'raise', 'range', 'rate', 'rather', 'reach', 'read', \n        'ready', 'real', 'reality', 'realize', 'really', 'reason', 'receive', \n        'recent', 'recently', 'recognize', 'record', 'red', 'reduce', \n        'reflect', 'region', 'relate', 'relationship', 'religious', 'remain', \n        'remember', 'remove', 'report', 'represent', 'republican', 'require', \n        'research', 'resource', 'respond', 'response', 'responsibility', \n        'rest', 'result', 'return', 'reveal', 'rich', 'right', 'rise', 'risk', \n        'road', 'rock', 'role', 'room', 'rule', 'run', 'safe', 'same', 'save', \n        'say', 'scene', 'school', 'science', 'scientist', 'score', 'sea', \n        'season', 'seat', 'second', 'section', 'security', 'see', 'seek', \n        'seem', 'sell', 'send', 'senior', 'sense', 'series', 'serious', \n        'serve', 'service', 'set', 'seven', 'several', 'sex', 'sexual', \n        'shake', 'share', 'she', 'shoot', 'short', 'shot', 'should', \n        'shoulder', 'show', 'side', 'sign', 'significant', 'similar', \n        'simple', 'simply', 'since', 'sing', 'single', 'sister', 'sit', \n        'site', 'situation', 'six', 'size', 'skill', 'skin', 'small', 'smile', \n        'so', 'social', 'society', 'soldier', 'some', 'somebody', 'someone', \n        'something', 'sometimes', 'son', 'song', 'soon', 'sort', 'sound', \n        'source', 'south', 'space', 'speak', 'special', 'specific', \n        'speech', 'spend', 'sport', 'spring', 'staff', 'stage', 'stand', \n        'standard', 'star', 'start', 'state', 'statement', 'station', \n        'stay', 'step', 'still', 'stock', 'stop', 'store', 'story', \n        'strategy', 'street', 'strong', 'structure', 'student', 'study', \n        'stuff', 'style', 'subject', 'success', 'successful', 'such', \n        'suddenly', 'suffer', 'suggest', 'summer', 'support', 'sure', \n        'surface', 'system', 'table', 'take', 'talk', 'task', 'tax', \n        'teach', 'teacher', 'team', 'technology', 'television', 'tell', \n        'ten', 'tend', 'term', 'test', 'than', 'thank', 'that', 'the', \n        'their', 'them', 'themselves', 'then', 'theory', 'there', 'these', \n        'they', 'thing', 'think', 'third', 'this', 'those', 'though', \n        'thought', 'thousand', 'threat', 'three', 'through', 'throughout', \n        'throw', 'thus', 'time', 'to', 'today', 'together', 'tonight', \n        'too', 'top', 'total', 'tough', 'toward', 'town', 'trade', \n        'traditional', 'training', 'travel', 'treat', 'treatment', \n        'tree', 'trial', 'trip', 'trouble', 'true', 'truth', 'try', \n        'turn', 'tv', 'two', 'type', 'under', 'understand', 'unit', \n        'until', 'up', 'upon', 'us', 'use', 'usually', 'value', \n        'various', 'very', 'victim', 'view', 'violence', 'visit', \n        'voice', 'vote', 'wait', 'walk', 'wall', 'want', 'war', \n        'watch', 'water', 'way', 'we', 'weapon', 'wear', 'week', \n        'weight', 'well', 'west', 'what', 'whatever', 'when', 'where', \n        'whether', 'which', 'while', 'white', 'who', 'whole', 'whom', \n        'why', 'wide', 'wife', 'will', 'win', 'wind', 'window', \n        'wish', 'with', 'within', 'without', 'woman', 'wonder', \n        'word', 'work', 'worker', 'world', 'worry', 'would', 'write', \n        'writer', 'wrong', 'yard', 'yeah', 'year', 'yes', 'yet', \n        'you', 'young', 'your', 'yourself'\n    }\n    for token in response.split():\n        cleaned = token.lower().strip(string.punctuation)\n        if cleaned and cleaned not in common_words:\n            return False\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    common_words = {'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take', 'people', 'into', 'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now', 'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two', 'how', 'our', 'work', 'first', 'well', 'way', 'even', 'new', 'want', 'because', 'any', 'these', 'give', 'day', 'most', 'us'}\n    words = re.findall(r\"\\b[\\w']+\\b\", response.lower())\n    for word in words:\n        cleaned = word.strip('!\\\"#$%&()*+,-./:;<=>?@[\\\\]^_`{|}~')\n        if cleaned and cleaned not in common_words:\n            return False\n    return True", 0.8888888888888888], ["def evaluate(response):\n    allowed_words = {'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'it', 'for', 'on', 'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from'}\n    words = response.split()\n    for word in words:\n        normalized = word.strip('.,!?;:\\'\\\"()').lower()\n        if normalized not in allowed_words:\n            return False\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    common_words = {'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take', 'people', 'into', 'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now', 'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two', 'how', 'our', 'work', 'first', 'well', 'way', 'even', 'new', 'want', 'because', 'any', 'these', 'give', 'day', 'most', 'us', 'is', 'are', 'was', 'were', 'am', 'been', 'being', 'has', 'had', 'do', 'does', 'did', 'doing', 'should', 'would', 'may', 'might', 'must', 'shall', 'can', 'could', 'will'}\n    words = response.split()\n    for word in words:\n        processed_word = re.sub(r'^[^a-z\\']*', '', word.lower())\n        processed_word = re.sub(r'[^a-z\\']*$', '', processed_word)\n        if processed_word == '':\n            continue\n        if processed_word not in common_words:\n            return False\n    return True", 1.0]], "cases": [["Python is a programming language", false], ["The be to of and a", true], ["the cat is on the mat", false], ["he wants to go to their house", false], ["Hello, world!", false], ["The mitochondria is complex.", false], ["It is, indeed.", false], ["I have a cat and a dog", false], ["He is at work.", true]]}
{"id": 11, "instruction": "Use words that end with '-ing'", "eval_func": [["def evaluate(response):\n    words = response.split()\n    return len(words) > 0 and all(word.endswith('ing') for word in words)", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if len(word) < 3 or not word.endswith('ing'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if not word.endswith('ing'):\n            return False\n    return True", 1.0]], "cases": [["ING", false], ["jumping", true], ["singing dancing", true], ["loving the feeling", false], ["loving the show", false], ["jumping dancing singing", true], ["ing", true], ["Singing a song", false], ["dancing", true], ["", false], ["running and jumping", false]]}
{"id": 12, "instruction": "Use only military lingo", "eval_func": [["def evaluate(response):\n    non_military_terms = {'yes', 'no', 'okay', 'hello', 'thanks', 'please', 'car', 'quickly', 'meeting', 'soon'}\n    words = response.lower().replace('.', '').replace(',', '').split()\n    for word in words:\n        if word in non_military_terms:\n            return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    military_terms = {'sitrep', 'eta', 'ao', 'cas', 'roger', 'copy', 'over', 'out', 'sop', 'wilco', 'actual', 'asap', 'bogey', 'civilian', 'collateral', 'ao', 'lz', 'medevac', 'cod', 'klicks', 'mikes', 'tangos', 'contact', 'sector', 'objective', 'grid', 'rally', 'evac', 'cas', 'cct', 'dasc', 'eod', 'fob', 'hvt', 'ied', 'oscar mike', 'tangos down'}\n    forbidden_terms = {'hello', 'hi', 'please', 'thanks', 'thank you', 'wanna', 'gonna', 'hey', 'okay', 'ok', 'yeah', 'yep', 'nah', 'nope', 'maybe', 'probably', 'dude', 'buddy', 'man', 'cool', 'awesome', 'nice', 'uh', 'well', 'like', 'hurry', 'quickly', 'stuff', 'things'}\n\n    response_lower = response.lower()\n    for term in forbidden_terms:\n        if term in response_lower:\n            return False\n    for term in military_terms:\n        if term in response_lower:\n            return True\n    return False", 0.8333333333333334], ["def evaluate(response):\n    military_terms = {'roger', 'affirmative', 'negative', 'wilco', 'over', 'out', 'eta', 'ao', 'lz', 'hq', 'sitrep', 'grid', 'zone', 'target', 'execute', 'actual', 'copy', 'alpha', 'bravo', 'charlie', 'sierra', 'tango', 'oscar', 'mike', 'medevac', 'cod', 'klick', 'recon', 'contact', 'break', 'intel', 'orders', 'status', 'verify'}\n    civilian_terms = {'yes', 'no', 'okay', 'hello', 'thanks', 'please', 'hey', 'hi', 'yeah', 'sure', 'maybe'}\n    lower_response = response.lower()\n    has_military = any(term in lower_response for term in military_terms)\n    has_civilian = any(term in lower_response for term in civilian_terms)\n    return has_military and not has_civilian", 0.9166666666666666]], "cases": [["We need to hurry to the objective.", false], ["Yes, I'll head there now. ETA 2 mikes.", false], ["Affirmative, we are Oscar Mike to the LZ.", true], ["Hey, need backup ASAP!", false], ["SITREP updated. Proceeding to AO.", true], ["Roger, but we need to move quickly.", false], ["Roger that, moving to grid Bravo-6.", true], ["Negative contact. Awaiting sitrep.", true], ["Affirmative. RTB at H-Hour.", true], ["Affirmative. Oscar Mike to LZ.", true], ["Sierra team: regroup at HQ ASAP. Out.", true], ["Deploy to grid 345678 ASAP.", true]]}
{"id": 13, "instruction": "Respond with a haiku (5-7-5 syllable structure)", "eval_func": [["def evaluate(response):\n    lines = [line.strip() for line in response.split('\\n') if line.strip()]\n    if len(lines) != 3:\n        return False\n    counts = []\n    for line in lines:\n        count = 0\n        prev_vowel = False\n        for c in line.lower():\n            if c in 'aeiouy':\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        counts.append(count if count > 0 else 1)\n    return counts == [5, 7, 5]", 0.8], ["def evaluate(response):\n    def count_syllables_in_word(word):\n        word = word.lower().strip(\"!.,?\")\n        if not word:\n            return 0\n        count = 0\n        vowels = 'aeiouy'\n        if word[0] in vowels:\n            count += 1\n        for i in range(1, len(word)):\n            if word[i] in vowels and word[i-1] not in vowels:\n                count += 1\n        if word.endswith('e'):\n            count -= 1\n        return max(1, count) if count > 0 else 1\n    def count_syllables_in_line(line):\n        words = line.split()\n        return sum(count_syllables_in_word(word) for word in words)\n    lines = [line.strip() for line in response.split('\\n')]\n    lines = [line for line in lines if line]\n    if len(lines) != 3:\n        return False\n    syllables = [count_syllables_in_line(line) for line in lines]\n    return syllables == [5, 7, 5]", 0.8], ["def evaluate(response):\n    def count_syllables(word):\n        word = word.lower().strip(\".,!?;:'\\\"\")\n        if not word:\n            return 0\n        vowels = 'aeiouy'\n        count = 0\n        if word[0] in vowels:\n            count += 1\n        for i in range(1, len(word)):\n            if word[i] in vowels and word[i-1] not in vowels:\n                count += 1\n        if word.endswith('e'):\n            count -= 1\n        if word.endswith('le') and len(word) > 2 and word[-3] not in vowels:\n            count += 1\n        return max(count, 1)\n    lines = [line.strip() for line in response.splitlines()]\n    lines = [line for line in lines if line]\n    if len(lines) != 3:\n        return False\n    syllables = []\n    for line in lines:\n        words = line.split()\n        total = 0\n        for word in words:\n            total += count_syllables(word)\n        syllables.append(total)\n    return syllables == [5, 7, 5]", 0.8], ["def evaluate(response):\n    def count_syllables(word):\n        word = word.lower().strip(\".,!?;:\")\n        if not word:\n            return 0\n        count = 0\n        vowels = 'aeiouy'\n        prev_vowel = False\n        for char in word:\n            if char in vowels:\n                if not prev_vowel:\n                    count +=1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if len(word) > 1 and word.endswith('e') and word[-2] not in vowels:\n            count -=1\n        return count if count > 0 else 1\n    lines = [line.strip() for line in response.split('\\n') if line.strip()]\n    if len(lines) !=3:\n        return False\n    syllables = []\n    for line in lines:\n        words = line.split()\n        line_syllables = sum(count_syllables(word) for word in words)\n        syllables.append(line_syllables)\n    return syllables == [5,7,5]", 0.8], ["def evaluate(response):\n    def count_syllables(word):\n        word = word.lower()\n        if not word:\n            return 0\n        count = 0\n        vowels = 'aeiouy'\n        prev_vowel = False\n        for char in word:\n            if char in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if word.endswith('e') and count > 1:\n            count -= 1\n        return max(count, 1)\n    \n    lines = [line.strip() for line in response.split('\\n')]\n    lines = [line for line in lines if line]\n    if len(lines) != 3:\n        return False\n    syllables = []\n    for line in lines:\n        words = line.split()\n        total = 0\n        for word in words:\n            total += count_syllables(word)\n        syllables.append(total)\n    return syllables == [5, 7, 5]", 0.8]], "cases": [["Not enough lines\nOnly two lines here", false], ["Five syllables here\nThis line has seven right now\nBut this one is six", false], ["Five syllables first\nThis line has seven syllables\nNow four here mistake", false], ["A single line\n", false], ["An old silent pond\nA frog jumps into the pond\nSplash! Silence again.", true]]}
{"id": 14, "instruction": "Answer in the form of a sonnet (14 lines with 10 syllables each)", "eval_func": [["def evaluate(response):\n    def count_syllables(line):\n        line = line.lower().strip()\n        if not line:\n            return 0\n        words = line.split()\n        total = 0\n        for word in words:\n            word = word.rstrip('.,!?;:\"')\n            if not word:\n                continue\n            count = 0\n            vowels = 'aeiouy'\n            prev_vowel = False\n            for char in word:\n                if char in vowels:\n                    if not prev_vowel:\n                        count += 1\n                    prev_vowel = True\n                else:\n                    prev_vowel = False\n            if word.endswith('e') and count > 1:\n                count -= 1\n            if count == 0:\n                count = 1\n            total += count\n        return total\n\n    lines = [line.strip() for line in response.split('\\n') if line.strip()]\n    if len(lines) != 14:\n        return False\n    for line in lines:\n        if count_syllables(line) != 10:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    def count_syllables(line):\n        vowels = 'aeiouyAEIOUY'\n        count = 0\n        line = line.lower()\n        words = line.split()\n        for word in words:\n            word = word.rstrip('e')\n            v_count = 0\n            prev_vowel = False\n            for char in word:\n                if char in 'aeiouy':\n                    if not prev_vowel:\n                        v_count += 1\n                        prev_vowel = True\n                    else:\n                        prev_vowel = True\n                else:\n                    prev_vowel = False\n            if v_count == 0:\n                v_count = 1\n            count += v_count\n        return count\n\n    lines = [line.strip() for line in response.split('\\n')]\n    non_empty_lines = [line for line in lines if line]\n    if len(non_empty_lines) != 14:\n        return False\n    for line in non_empty_lines:\n        if count_syllables(line) != 10:\n            return False\n    return True", 1.0], ["import re\n\ndef count_syllables_in_word(word):\n    word = re.sub(r'[^a-zA-Z]', '', word.lower())\n    if not word:\n        return 0\n    count = 0\n    vowels = 'aeiouy'\n    in_vowel = False\n    for char in word:\n        if char in vowels:\n            if not in_vowel:\n                count += 1\n            in_vowel = True\n        else:\n            in_vowel = False\n    if len(word) > 1 and word[-1] == 'e' and word[-2] not in vowels:\n        count -= 1\n    return max(1, count)\n\ndef count_syllables(line):\n    words = re.findall(r\"\\b\\w+(?:'\\w+)?\\b\", line)\n    return sum(count_syllables_in_word(word) for word in words)\n\ndef evaluate(response):\n    lines = [line.strip() for line in response.split('\\n')]\n    lines = [line for line in lines if line]\n    if len(lines) != 14:\n        return False\n    for line in lines:\n        if count_syllables(line) != 10:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    def count_syllables_in_word(word):\n        vowels = 'aeiouy'\n        count = 0\n        word = word.lower()\n        if not word:\n            return 0\n        if word[0] == 'y':\n            word = word[1:]\n        if not word:\n            return 0\n        prev_vowel = False\n        for char in word:\n            if char in vowels:\n                if not prev_vowel:\n                    count +=1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if word[-1] == 'e' and count >1:\n            count -=1\n        return count if count >0 else 1\n    \n    lines = [line.strip() for line in response.split('\\n')]\n    non_empty_lines = [line for line in lines if line]\n    if len(non_empty_lines) !=14:\n        return False\n    for line in non_empty_lines:\n        words = line.split()\n        syllables = 0\n        for word in words:\n            syllables += count_syllables_in_word(word)\n        if syllables !=10:\n            return False\n    return True", 1.0]], "cases": [["Only thirteen lines are present here.\nEach line has ten syllables, that's clear.\nBut since the count is short by one line,\nThe function's output will be just fine?\nNo, fourteen's required, so this will fail.\nNo matter if the syllables are well.\nThe line count's wrong, so false it must return.\nEven if the rest are perfect, then.\nLine eight is here, but where's the rest?\nWe need six more to pass the test.\nBut wait, that's not the case at all.\nThirteen's the count, and that's the fall.\nFourteen's required, so false is due.\nThis case ensures that the code stays true.", false], ["This line has eleven syllables here, oops.\nThe rest are fine with ten each, no mistake.\nBut one line's wrong, so false it must return.\nAll others pass, but this one's overgrown.\nThe check is strict, no errors are allowed.\nEach line must be precise, or else it's out.\nBut here's the catch: this line is just too long.\nAnd this one's short, now syllables are gone.\nThe rest are correct, but two lines have failed.\nSo overall, the function's verdict is nailed.\nThe count is wrong, so false is the result.\nNo sonnet here, the code will now insult.\nFourteen lines, yes, but with errors inside.\nThus, false is returned; the rules were defied.", false]]}
{"id": 15, "instruction": "Use only monosyllabic words", "eval_func": [["import re\n\ndef evaluate(response):\n    def count_syllables(word):\n        word = word.lower().replace(\"'\", \"\")\n        if not word:\n            return 0\n        vowels = 'aeiouy'\n        count = 0\n        prev_vowel = False\n        for char in word:\n            if char in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if len(word) > 1 and word[-1] == 'e' and count > 1:\n            count -= 1\n        return max(count, 1)\n\n    tokens = response.split()\n    for token in tokens:\n        cleaned = re.sub(r'^[^a-zA-Z]+', '', token)\n        cleaned = re.sub(r'[^a-zA-Z]+$', '', cleaned)\n        parts = cleaned.split('-')\n        for part in parts:\n            if not part:\n                continue\n            if count_syllables(part) != 1:\n                return False\n    return True", 1.0], ["import string\n\ndef evaluate(response):\n    def is_monosyllabic(word):\n        word = word.strip(string.punctuation).lower()\n        if not word:\n            return True\n        vowels = 'aeiouy'\n        count = 0\n        prev_vowel = False\n        for char in word:\n            if char in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if word.endswith('e') and count > 1:\n            count -= 1\n        return count == 1\n\n    words = response.split()\n    for word in words:\n        if not is_monosyllabic(word):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    def count_syllables(word):\n        word = re.sub(r'^[^a-zA-Z]+', '', word)\n        word = re.sub(r'[^a-zA-Z]+$', '', word)\n        if not word:\n            return 0\n        vowels = {'a', 'e', 'i', 'o', 'u'}\n        count = 0\n        prev_vowel = False\n        for char in word.lower():\n            if char in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if word.endswith('e') and count > 1:\n            count -= 1\n        return max(count, 1)\n    \n    for word in response.split():\n        if count_syllables(word) != 1:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    for word in response.split():\n        stripped_word = re.sub(r'^[^a-zA-Z]*', '', word)\n        stripped_word = re.sub(r'[^a-zA-Z]*$', '', stripped_word)\n        stripped_word = stripped_word.lower()\n        if not stripped_word:\n            continue\n        vowel_groups = re.findall(r'[aeiouy]+', stripped_word)\n        if len(vowel_groups) > 1:\n            return False\n        if len(vowel_groups) == 0:\n            if any(c.isalpha() for c in stripped_word):\n                continue\n            else:\n                continue\n    return True", 1.0]], "cases": [["She eats apples.", false], ["The cat sat on the mat.", true], ["Up-to-date info", false]]}
{"id": 16, "instruction": "Answer with words in alphabetical order", "eval_func": [["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for i in range(len(words)-1):\n        if words[i].lower() > words[i+1].lower():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for i in range(len(words) - 1):\n        if words[i] > words[i+1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for i in range(1, len(words)):\n        if words[i] < words[i-1]:\n            return False\n    return True", 1.0]], "cases": [["banana apple", false], ["apple banana cherry", true], ["", false], ["Apple banana", true]]}
{"id": 17, "instruction": "Write the response as a limerick", "eval_func": [["def evaluate(response):\n    lines = [line.strip() for line in response.strip().split('\\n')]\n    if len(lines) != 5:\n        return False\n    for line in lines:\n        if not line:\n            return False\n    last_words = [line.split()[-1].lower() for line in lines]\n    a_rhymes = [last_words[i][-2:] for i in [0, 1, 4]]\n    if not (a_rhymes[0] == a_rhymes[1] == a_rhymes[2]):\n        return False\n    b_rhymes = [last_words[i][-2:] for i in [2, 3]]\n    if b_rhymes[0] != b_rhymes[1]:\n        return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    lines = [line.strip() for line in response.split('\\n') if line.strip()]\n    if len(lines) != 5:\n        return False\n    last_words = []\n    for line in lines:\n        words = re.split(r'\\s+', line)\n        if not words:\n            return False\n        last_word = words[-1].lower().rstrip('.,!?;:\"')\n        if not last_word:\n            return False\n        last_words.append(last_word)\n    a1 = last_words[0][-2:] if len(last_words[0]) >= 2 else last_words[0]\n    a2 = last_words[1][-2:] if len(last_words[1]) >= 2 else last_words[1]\n    a5 = last_words[4][-2:] if len(last_words[4]) >= 2 else last_words[4]\n    if not (a1 == a2 == a5):\n        return False\n    b3 = last_words[2][-2:] if len(last_words[2]) >= 2 else last_words[2]\n    b4 = last_words[3][-2:] if len(last_words[3]) >= 2 else last_words[3]\n    return b3 == b4", 0.8], ["def evaluate(response):\n    lines = [line.strip() for line in response.split('\\n') if line.strip()]\n    if len(lines) != 5:\n        return False\n    last_words = []\n    for line in lines:\n        words = line.split()\n        if not words:\n            return False\n        last_word = words[-1].lower().rstrip('.,?!;:\\\"\\'')\n        if len(last_word) < 2:\n            return False\n        last_words.append(last_word)\n    a_ends = [last_words[i][-2:] for i in [0, 1, 4]]\n    if len(set(a_ends)) != 1:\n        return False\n    b_ends = [last_words[i][-2:] for i in [2, 3]]\n    if len(set(b_ends)) != 1:\n        return False\n    return a_ends[0] != b_ends[0]", 1.0], ["def evaluate(response):\n    lines = [line.strip() for line in response.split('\\n') if line.strip()]\n    if len(lines) != 5:\n        return False\n    last_words = []\n    for line in lines:\n        words = line.split()\n        if not words:\n            return False\n        last_word = words[-1].lower().rstrip('.,!?;:\"')\n        last_words.append(last_word)\n    endings = [word[-2:] if len(word)>=2 else word for word in last_words]\n    a_group = [endings[0], endings[1], endings[4]]\n    b_group = [endings[2], endings[3]]\n    return a_group[0] == a_group[1] == a_group[2] and b_group[0] == b_group[1] and a_group[0] != b_group[0]", 1.0], ["def evaluate(response):\n    def get_ending(line):\n        line = line.rstrip('.,?!;:\\\"\\'')\n        words = line.split()\n        if not words:\n            return None\n        last_word = words[-1].lower()\n        return last_word[-3:] if len(last_word) >= 3 else last_word\n    \n    lines = [line.strip() for line in response.split('\\n') if line.strip()]\n    if len(lines) != 5:\n        return False\n    \n    endings = [get_ending(line) for line in lines]\n    if None in endings:\n        return False\n    \n    a1, a2, b1, b2, a3 = endings\n    return a1 == a2 == a3 and b1 == b2", 1.0]], "cases": [["A man who sailed to Peru\nWhose llama would not say 'moo'\nThey jumped on a ship\nThen ate a long strip\nAnd laughed all the way to the zoo", false], ["There once was a cat from Spain\\nWho loved to dance in the rain\\nShe jumped so high\\nThen touched the sky\\nAnd now she's a pilot on a plane.", false], ["First line here\\nSecond line there\\nThird line short\\nFourth line caught\\nFifth line everywhere.", false], ["There once was a cat named Lou\nWho chased mice on the pew\nHe fell down with grace\nThen lost his red face\nNow he's blue in the hue", false], ["A cat sat on a mat\nHe wore a tiny hat\nHe saw a bat\nAnd chased a rat\nNow he's a happy cat!", false]]}
{"id": 19, "instruction": "Respond with a six-word story", "eval_func": [["def evaluate(response):\n    words = response.strip().split()\n    return len(words) == 6", 1.0], ["def evaluate(response):\n    return len(response.split()) == 6", 1.0], ["def evaluate(response):\n    return len(response.strip().split()) == 6", 1.0]], "cases": [["The last human left Earth silently.", true], ["Short sentence.", false], ["She found love, then lost everything.", true], ["Life goes on without him.", false], ["   One two three four five six   ", true], ["   One   two   three   four   five   six   ", true], ["Five words are not enough.", false], ["Stars whispered secrets to the night.", true], ["This response has exactly seven words here.", false], ["For sale: baby shoes, never worn.", true], ["Life goes on, they said.", false], ["Short story here", false], ["Alone in the dark. Silence deafening.", true], ["Hello world this is a test", true], ["She smiled, then vanished into mist.", true]]}
{"id": 20, "instruction": "Include at least three rhyming pairs", "eval_func": [["import string\nfrom collections import defaultdict\n\ndef evaluate(response):\n    def get_words(text):\n        words = text.lower().split()\n        processed = []\n        for word in words:\n            stripped = word.strip(string.punctuation)\n            if len(stripped) >= 2:\n                processed.append(stripped)\n        return processed\n\n    words = get_words(response)\n    endings = defaultdict(int)\n    for word in words:\n        if len(word) < 2:\n            continue\n        ending = word[-2:]\n        endings[ending] += 1\n\n    total_pairs = 0\n    for count in endings.values():\n        if count >= 2:\n            total_pairs += count * (count - 1) // 2\n\n    return total_pairs >= 3", 0.8333333333333334], ["import re\ndef evaluate(response):\n    words = response.split()\n    cleaned = []\n    for word in words:\n        cleaned_word = re.sub(r'^[^a-zA-Z]+', '', word)\n        cleaned_word = re.sub(r'[^a-zA-Z]+$', '', cleaned_word)\n        cleaned_word = cleaned_word.lower()\n        if cleaned_word:\n            cleaned.append(cleaned_word)\n    pairs = set()\n    for i in range(len(cleaned)):\n        for j in range(i+1, len(cleaned)):\n            word1 = cleaned[i]\n            word2 = cleaned[j]\n            suffix1 = word1[-2:] if len(word1) >=2 else word1\n            suffix2 = word2[-2:] if len(word2) >=2 else word2\n            if suffix1 == suffix2:\n                pairs.add((i, j))\n    return len(pairs) >= 3", 0.8333333333333334], ["def evaluate(response):\n    import re\n    from collections import defaultdict\n    words = re.findall(r\"\\b[\\w']+\\b\", response.lower())\n    endings = [word[-2:] if len(word) >=2 else word for word in words]\n    groups = defaultdict(int)\n    for end in endings:\n        groups[end] += 1\n    total_pairs = 0\n    for count in groups.values():\n        if count >= 2:\n            total_pairs += count * (count -1) // 2\n    return total_pairs >=3", 0.8333333333333334], ["import re\nfrom itertools import combinations\n\ndef evaluate(response):\n    words = []\n    for token in response.split():\n        processed = re.sub(r'^[^a-zA-Z]*(.*?)[^a-zA-Z]*$', r'\\1', token)\n        processed = processed.lower()\n        if processed:\n            words.append(processed)\n    pairs = combinations(words, 2)\n    count = 0\n    for a, b in pairs:\n        if a == b:\n            continue\n        suffix_a = a[-2:] if len(a)>=2 else a\n        suffix_b = b[-2:] if len(b)>=2 else b\n        if suffix_a == suffix_b:\n            count += 1\n            if count >=3:\n                return True\n    return False", 1.0]], "cases": [["Hello world, how are you?", false], ["Hello world!", false], ["Hop top pop stop", true], ["The cat sat on the mat, then met a bet and let go.", true], ["The cat sat. The dog jog.", false], ["Cat hat bat sat", true]]}
{"id": 21, "instruction": "Write the response in iambic pentameter", "eval_func": [["def evaluate(response):\n    def count_syllables(word):\n        word = word.lower().strip(\"'\").replace(\"'\", '')\n        word = ''.join([c for c in word if c in 'abcdefghijklmnopqrstuvwxyz'])\n        if not word:\n            return 0\n        vowels = 'aeiouy'\n        count = 0\n        prev_vowel = False\n        for c in word:\n            if c in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if word.endswith('e') and count > 1:\n            count -= 1\n        return max(count, 1)\n    \n    lines = response.split('\\n')\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        syllables = sum(count_syllables(word) for word in line.split())\n        if syllables != 10:\n            return False\n    return True", 1.0], ["import re\n\ndef count_syllables(word):\n    word = re.sub(r'[^a-zA-Z]', '', word).lower()\n    if not word:\n        return 0\n    vowels = 'aeiouy'\n    count = 0\n    prev_vowel = False\n    for char in word:\n        if char in vowels:\n            if not prev_vowel:\n                count += 1\n            prev_vowel = True\n        else:\n            prev_vowel = False\n    # Adjust for silent 'e'\n    if len(word) > 1 and word[-1] == 'e' and word[-2] not in vowels:\n        count -= 1\n    return max(count, 1)\n\ndef evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        line = re.sub(r'[^\\w\\s]', '', line).strip()\n        if not line:\n            continue\n        words = line.split()\n        syllables = sum(count_syllables(word) for word in words)\n        if syllables != 10:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    def count_syllables(word):\n        cleaned = ''.join([c for c in word.lower() if c.isalpha() or c == \"'\"])\n        if not cleaned:\n            return 0\n        vowels = 'aeiouy'\n        count = 0\n        prev_vowel = False\n        for char in cleaned:\n            if char in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if cleaned.endswith('e') and count > 1:\n            count -= 1\n        return max(1, count)\n    \n    lines = response.strip().split('\\n')\n    for line in lines:\n        words = line.split()\n        syllables = 0\n        for word in words:\n            syllables += count_syllables(word)\n        if syllables != 10:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    def count_syllables(word):\n        word = word.lower().strip(\".,!?;:\")\n        vowels = 'aeiouy'\n        count = 0\n        prev_vowel = False\n        for char in word:\n            if char in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        if word.endswith('e'):\n            count -= 1\n        return count if count > 0 else 1\n    lines = response.split('\\n')\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        words = line.split()\n        syllables = sum(count_syllables(word) for word in words)\n        if syllables != 10:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    def count_syllables(word):\n        word = word.lower().strip(\"'\")\n        if not word:\n            return 0\n        if word.endswith('e'):\n            word = word[:-1]\n        vowels = 'aeiouy'\n        count = 0\n        prev_vowel = False\n        for char in word:\n            if char in vowels:\n                if not prev_vowel:\n                    count += 1\n                prev_vowel = True\n            else:\n                prev_vowel = False\n        return max(1, count) if count > 0 else 1\n\n    lines = response.split('\\n')\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        words = re.findall(r\"\\b[\\w']+\\b\", line)\n        syllables = sum(count_syllables(word) for word in words)\n        if syllables != 10:\n            return False\n    return True", 1.0]], "cases": [["A line with ten syllables here.\\nAnother line that has only nine.", false], ["But soft, what light through yonder window breaks", true], ["Shall I compare thee to a summer's day?", true], ["This line clearly has eleven syllables.", false], ["This line has the wrong number of syllables here", false], ["But soft, what light through yonder window breaks?", true]]}
{"id": 22, "instruction": "Use alliteration throughout your answer", "eval_func": [["def evaluate(response):\n    words = [word.strip() for word in response.split() if word.strip()]\n    if len(words) < 2:\n        return False\n    first_char = words[0][0].lower()\n    if not first_char.isalpha():\n        return False\n    for word in words:\n        if word[0].lower() != first_char:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = [word.strip().lower() for word in response.split() if word.strip()]\n    if not words:\n        return False\n    first_char = words[0][0]\n    for word in words:\n        if word[0] != first_char:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.strip().split()\n    if len(words) < 2:\n        return False\n    first_char = words[0][0].lower()\n    for word in words:\n        if word[0].lower() != first_char:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.strip().split()\n    if not words:\n        return False\n    first_char = words[0][0].lower()\n    for word in words[1:]:\n        if not word:\n            continue\n        if word[0].lower() != first_char:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.strip().split()\n    if not words:\n        return False\n    first_char = words[0][0].lower()\n    for word in words:\n        if word[0].lower() != first_char:\n            return False\n    return True", 1.0]], "cases": [["Silly snakes slide smoothly sideways.", true], ["Big bad bears bounce boldly", true], ["Peter Piper picked a peck of pickled peppers", false], ["Many merry monkeys munch on melons.", false], ["Silly snakes silently slither south", true], ["Jumping jellybeans jiggle joyfully.", true], ["Silly snakes slither smoothly.", true]]}
{"id": 23, "instruction": "Write the response in future tense only", "eval_func": [["def evaluate(response):\n    # Expand common contractions for 'll\n    response = response.replace(\"'ll\", \" will\")\n    response_lower = response.lower()\n    # Check for presence of 'will' or 'shall'\n    if 'will' not in response_lower and 'shall' not in response_lower:\n        return False\n    # Check for past tense verbs ending with 'ed'\n    words = response_lower.split()\n    for word in words:\n        if word.endswith('ed'):\n            return False\n    # Check for third person present tense verbs ending with 's'\n    for word in words:\n        if word.endswith('s'):\n            # Skip words ending with 'ss', 'us', 'is', etc.\n            if len(word) > 2 and (word.endswith('ss') or word[-2] in ['u', 'i', 'o', 's']):\n                continue\n            return False\n    return True", 1.0]], "cases": [["They'll start the meeting in an hour.", true], ["She finishes her homework every day.", false], ["I will submit the report by tomorrow.", true]]}
{"id": 24, "instruction": "Use only the first half of the alphabet (A-M)", "eval_func": [["def evaluate(response):\n    for char in response:\n        if char.isalpha():\n            upper_char = char.upper()\n            if not ('A' <= upper_char <= 'M'):\n                return False\n    return True", 1.0], ["def evaluate(response):\n    for c in response:\n        if c.isalpha():\n            if c.upper() > 'M':\n                return False\n    return True", 1.0], ["def evaluate(response):\n    for char in response:\n        if char.isalpha():\n            upper_char = char.upper()\n            if upper_char < 'A' or upper_char > 'M':\n                return False\n    return True", 1.0]], "cases": [["Adam", true], ["ACEGIKM", true], ["Hi! 123", true], ["alm", true], ["H1M", true], ["Hi Mom", false], ["Noon", false], ["Nope", false], ["ACabM", true], ["Hello", false], ["Nimbus", false], ["Camel123", true], ["Hi! M.", true], ["Apple", false], ["Madam", true]]}
{"id": 25, "instruction": "Use only questions to form your reply", "eval_func": [["def evaluate(response):\n    return not ('!' in response or '.' in response) and response.endswith('?') and len(response) > 0", 1.0], ["import re\ndef evaluate(response):\n    stripped = response.strip()\n    if not stripped.endswith('?'):\n        return False\n    if re.search(r'[.!](?=\\s+|$)', stripped):\n        return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    stripped = response.strip()\n    if not stripped:\n        return False\n    if stripped[-1] != '?':\n        return False\n    pattern = re.compile(r'([.!?])(\\s+|$)')\n    matches = list(pattern.finditer(response))\n    if not matches:\n        return False\n    for match in matches:\n        if match.group(1) != '?':\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    if re.search(r'[.!](?=\\s|$)', response):\n        return False\n    if not response.endswith('?'):\n        return False\n    if '?' not in response:\n        return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    stripped = response.strip()\n    if not stripped:\n        return False\n    if '?' not in stripped:\n        return False\n    if re.search(r'[.!](?=\\s|$)', stripped):\n        return False\n    if not stripped.endswith('?'):\n        return False\n    return True", 1.0]], "cases": [["How are you", false], ["How are you? What's your name?", true], ["I am fine. How are you?", false]]}
{"id": 26, "instruction": "Use only words that start and end with the same letter", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word:\n            return False\n        first = word[0]\n        last = word[-1]\n        if not first.isalpha() or not last.isalpha():\n            return False\n        if first != last:\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    for word in response.split():\n        if not word:\n            return False\n        first, last = word[0], word[-1]\n        if not (first.isalpha() and last.isalpha()):\n            return False\n        if first.lower() != last.lower():\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    for word in response.split():\n        if not word:\n            continue\n        if word[0] != word[-1]:\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    for word in response.split():\n        if word[0] != word[-1]:\n            return False\n    return True", 0.9090909090909091]], "cases": [["abba", true], ["Anna", false], ["A man", false], ["hello!", false], ["a", true], ["noon radar", true], ["hello", false], ["Anna", true], ["madam radar", true], ["apple", false], ["madam", true]]}
{"id": 27, "instruction": "Write the response in Morse code", "eval_func": [["def evaluate(response):\n    allowed = {' ', '.', '-'}\n    for char in response:\n        if char not in allowed:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    allowed = {' ', '.', '-'}\n    if not response:\n        return False\n    for char in response:\n        if char not in allowed:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    allowed = {'.', '-', ' '}\n    if not response:\n        return False\n    for c in response:\n        if c not in allowed:\n            return False\n    if '.' not in response and '-' not in response:\n        return False\n    return True", 1.0]], "cases": [["Hello", false], [".... . .-.. .-.. ---", true], ["..../-..", false]]}
{"id": 28, "instruction": "Use only words that are colors", "eval_func": [["def evaluate(response):\n    color_set = {\n        'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure',\n        'beige', 'bisque', 'black', 'blanchedalmond', 'blue',\n        'blueviolet', 'brown', 'burlywood', 'cadetblue',\n        'chartreuse', 'chocolate', 'coral', 'cornflowerblue',\n        'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan',\n        'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey',\n        'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange',\n        'darkorchid', 'darkred', 'darksalmon', 'darkseagreen',\n        'darkslateblue', 'darkslategray', 'darkslategrey',\n        'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue',\n        'dimgray', 'dimgrey', 'dodgerblue', 'firebrick',\n        'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro',\n        'ghostwhite', 'gold', 'goldenrod', 'gray', 'green',\n        'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo',\n        'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen',\n        'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan',\n        'lightgoldenrodyellow', 'lightgray', 'lightgreen',\n        'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen',\n        'lightskyblue', 'lightslategray', 'lightslategrey',\n        'lightsteelblue', 'lightyellow', 'lime', 'limegreen',\n        'linen', 'magenta', 'maroon', 'mediumaquamarine',\n        'mediumblue', 'mediumorchid', 'mediumpurple',\n        'mediumseagreen', 'mediumslateblue', 'mediumspringgreen',\n        'mediumturquoise', 'mediumvioletred', 'midnightblue',\n        'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy',\n        'oldlace', 'olive', 'olivedrab', 'orange', 'orangered',\n        'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise',\n        'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink',\n        'plum', 'powderblue', 'purple', 'rebeccapurple', 'red',\n        'rosybrown', 'royalblue', 'saddlebrown', 'salmon',\n        'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver',\n        'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow',\n        'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato',\n        'turquoise', 'violet', 'wheat', 'white', 'whitesmoke',\n        'yellow', 'yellowgreen'\n    }\n    words = response.split()\n    for word in words:\n        if word.lower() not in color_set:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    colors = {'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'}\n    words = response.split()\n    for word in words:\n        if word.lower() not in colors:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    colors = {\n        \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\", \"bisque\", \"black\",\n        \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\", \"burlywood\", \"cadetblue\", \"chartreuse\",\n        \"chocolate\", \"coral\", \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\",\n        \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkgrey\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n        \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\", \"darkslategray\",\n        \"darkslategrey\", \"darkturquoise\", \"darkviolet\", \"deeppink\", \"deepskyblue\", \"dimgray\", \"dimgrey\",\n        \"dodgerblue\", \"firebrick\", \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\",\n        \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"honeydew\", \"hotpink\", \"indianred\", \"indigo\", \"ivory\",\n        \"khaki\", \"lavender\", \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n        \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightgrey\", \"lightpink\",\n        \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightslategrey\", \"lightsteelblue\",\n        \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\", \"mediumblue\",\n        \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\",\n        \"mediumturquoise\", \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n        \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\", \"orchid\",\n        \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\", \"peru\",\n        \"pink\", \"plum\", \"powderblue\", \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\",\n        \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n        \"slateblue\", \"slategray\", \"slategrey\", \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\",\n        \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\", \"yellow\", \"yellowgreen\"\n    }\n    words = response.strip().split()\n    for word in words:\n        if word.lower() not in colors:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    color_names = {'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'}\n    words = response.strip().split()\n    for word in words:\n        if word.lower() not in color_names:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    color_names = {\n        'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond',\n        'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue',\n        'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgrey', 'darkgreen',\n        'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon',\n        'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink',\n        'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia',\n        'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'grey', 'green', 'greenyellow', 'honeydew', 'hotpink',\n        'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon',\n        'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgrey', 'lightgreen',\n        'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey',\n        'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine',\n        'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen',\n        'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite',\n        'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen',\n        'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple',\n        'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen',\n        'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen',\n        'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke',\n        'yellow', 'yellowgreen'\n    }\n    words = response.strip().split()\n    return all(word.lower() in color_names for word in words)", 1.0]], "cases": [["blue", true], ["red blue green", true], ["Apple", false], ["DarkRed Silver", true], ["hello", false], ["DarkMagenta", true], ["red blue yellow", true], ["DarkGreen", true], ["apple crimson", false], ["DarkSlateGray", true], ["blue green yellow", true]]}
{"id": 29, "instruction": "Use only the second half of the alphabet (N-Z)", "eval_func": [["def evaluate(response):\n    for char in response:\n        if char.isalpha():\n            upper_char = char.upper()\n            if not ('N' <= upper_char <= 'Z'):\n                return False\n    return True", 1.0], ["def evaluate(response):\n    for c in response:\n        if c.isalpha():\n            if not ((c >= 'N' and c <= 'Z') or (c >= 'n' and c <= 'z')):\n                return False\n    return True", 1.0], ["def evaluate(response):\n    for c in response:\n        if c.isalpha():\n            lower_c = c.lower()\n            if lower_c < 'n' or lower_c > 'z':\n                return False\n    return True", 1.0]], "cases": [["nop", true], ["nOpZ", true], ["n123Z", true], ["nzon", true], ["NOZ", true], ["Hello", false], ["Test123!", false], ["123z", true], ["Apple", false]]}
{"id": 30, "instruction": "Answer with each sentence decreasing in word count", "eval_func": [["def evaluate(response):\n    import re\n    sentences = [s.strip() for s in re.split(r'[.!?]', response) if s.strip()]\n    if not sentences:\n        return False\n    prev_count = None\n    for sentence in sentences:\n        current_count = len(sentence.split())\n        if prev_count is not None:\n            if current_count >= prev_count:\n                return False\n        prev_count = current_count\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = [s.strip() for s in re.split(r'[.!?]+', response) if s.strip()]\n    if len(sentences) < 2:\n        return True\n    word_counts = [len(s.split()) for s in sentences]\n    for i in range(1, len(word_counts)):\n        if word_counts[i] >= word_counts[i-1]:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]+', response)\n    sentences = [s.strip() for s in sentences if s.strip()]\n    word_counts = [len(s.split()) for s in sentences]\n    if not word_counts:\n        return False\n    for i in range(1, len(word_counts)):\n        if word_counts[i] >= word_counts[i-1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sentences = [s.strip() for s in response.split('.') if s.strip()]\n    counts = [len(s.split()) for s in sentences]\n    if len(counts) < 1:\n        return False\n    for i in range(1, len(counts)):\n        if counts[i] >= counts[i-1]:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = [s.strip() for s in re.split(r'[.!?]', response) if s.strip()]\n    if not sentences:\n        return False\n    word_counts = [len(sentence.split()) for sentence in sentences]\n    for i in range(1, len(word_counts)):\n        if word_counts[i] >= word_counts[i-1]:\n            return False\n    return True", 1.0]], "cases": [["Only one sentence here.", true], ["Only one sentence.", true], ["Four words here now. Three words here. Two words. Single.", true], ["This is a test. Short one.", true], ["Two words. Another two. One.", false], ["Hello. Five words in this sentence.", false], ["Just a single sentence.", true], ["One. Two words. Three words here.", false], ["Six words here now yes. Five words here now. Three words. One.", true]]}
{"id": 31, "instruction": "Respond with a list of bullet points", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    has_content = False\n    for line in lines:\n        stripped = line.lstrip()\n        if stripped:\n            has_content = True\n            if not (stripped.startswith('- ') or stripped.startswith('* ')):\n                return False\n    return has_content", 1.0], ["import re\n\ndef evaluate(response):\n    lines = response.split('\\n')\n    if not lines:\n        return False\n    for line in lines:\n        stripped = line.strip()\n        if not stripped:\n            return False\n        if not re.match(r'^[-*•]\\s+\\S+', stripped):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    bullets = {'-', '*', '+', '•', '·', '‣', '⁃'}\n    lines = response.split('\\n')\n    has_bullet = False\n    for line in lines:\n        stripped = line.lstrip()\n        if not stripped:\n            continue\n        if stripped[0] in bullets:\n            has_bullet = True\n        else:\n            return False\n    return has_bullet", 1.0], ["def evaluate(response):\n    bullets = {'-', '*', '•'}\n    lines = response.split('\\n')\n    has_content = False\n    for line in lines:\n        stripped = line.strip()\n        if not stripped:\n            continue\n        if stripped[0] not in bullets:\n            return False\n        has_content = True\n    return has_content", 1.0], ["def evaluate(response):\n    bullets = {'-', '*', '+'}\n    lines = [line.strip() for line in response.strip().split('\\n')]\n    if not lines:\n        return False\n    for line in lines:\n        if not line:\n            return False\n        if len(line) < 2 or line[0] not in bullets or line[1] != ' ':\n            return False\n    return True", 1.0]], "cases": [["- Item 1\\n- Item 2", true], ["Fruits:\\n- Apple\\n- Banana", false], ["Hello there", false], ["  * Bullet with spaces  ", true], ["- Apple\\n* Banana\\n+ Cherry", true]]}
{"id": 35, "instruction": "Answer with each word starting with the next letter of the alphabet", "eval_func": [["def evaluate(response):\n    words = response.strip().split()\n    if not words:\n        return False\n    for index, word in enumerate(words):\n        expected_letter = chr(ord('A') + (index % 26))\n        if word[0].upper() != expected_letter:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for i, word in enumerate(words):\n        first_char = word[0].upper()\n        expected_char = chr(ord('A') + i % 26)\n        if first_char != expected_char:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for i, word in enumerate(words):\n        current_char = word[0].lower()\n        expected_char = chr(ord('a') + (i % 26))\n        if current_char != expected_char:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    expected = ord('A')\n    for word in words:\n        if not word:\n            return False\n        first_char = word[0].upper()\n        if not first_char.isalpha():\n            return False\n        current = ord(first_char)\n        if current != expected:\n            return False\n        expected += 1\n    return True", 0.8571428571428571]], "cases": [["A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A", true], ["Boy Cat Deer", false], ["a b c", true], ["Apple Banana Cherry", true], ["Apple Banana Cookie", true], ["a cat", false], ["A 2nd", false]]}
{"id": 37, "instruction": "Alternate sentences between questions and exclamations", "eval_func": [["import re\n\ndef evaluate(response):\n    stripped = response.strip()\n    if not stripped:\n        return False\n    sentences = re.findall(r'[^!?]*[!?]', stripped)\n    if not sentences:\n        return False\n    if ''.join(sentences) != stripped:\n        return False\n    prev = None\n    for sent in sentences:\n        if not sent:\n            return False\n        last_char = sent[-1]\n        if last_char not in ('!', '?'):\n            return False\n        if prev is None:\n            prev = last_char\n        else:\n            if last_char == prev:\n                return False\n            prev = last_char\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'(?<=[!?])\\s+', response.strip())\n    if not sentences:\n        return False\n    for sent in sentences:\n        if not sent or sent[-1] not in ('?', '!'):\n            return False\n    prev = None\n    for sent in sentences:\n        current = sent[-1]\n        if prev is not None and current == prev:\n            return False\n        prev = current\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    pattern = re.compile(r'([^!?]*[!?])(?=\\s+|$)')\n    matches = list(pattern.finditer(response))\n    if not matches:\n        return False\n    last_end = 0\n    for match in matches:\n        start, end = match.start(), match.end()\n        if start != last_end:\n            return False\n        last_end = end\n    if last_end != len(response):\n        return False\n    sentences = [m.group(0).strip() for m in matches]\n    if not sentences:\n        return False\n    for sentence in sentences:\n        if not sentence or sentence[-1] not in ('?', '!'):\n            return False\n    prev = sentences[0][-1]\n    for i in range(1, len(sentences)):\n        current = sentences[i][-1]\n        if current == prev:\n            return False\n        prev = current\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    stripped = response.strip()\n    sentences = re.findall(r'[^!?]*[!?]', stripped)\n    if ''.join(sentences) != stripped:\n        return False\n    punctuations = [s[-1] for s in sentences]\n    for i in range(1, len(punctuations)):\n        if punctuations[i] == punctuations[i-1]:\n            return False\n    return True", 0.8888888888888888]], "cases": [["Hello? How are you!", true], ["Hi! How are you? Awesome!", true], ["Hi! How are you? Great!", true], ["Wow! Amazing! No?", false], ["Is it raining? What a beautiful day! Can we go outside?", true], ["Wow! Amazing!", false], ["Yes! No! Maybe?", false], ["What? No way! Really?", true], ["What is that. Really?", false]]}
{"id": 38, "instruction": "Avoid using any punctuation marks", "eval_func": [["import string\n\ndef evaluate(response):\n    punctuation = set(string.punctuation)\n    for char in response:\n        if char in punctuation:\n            return False\n    return True", 1.0], ["import unicodedata\ndef evaluate(response):\n    for char in response:\n        if unicodedata.category(char).startswith('P'):\n            return False\n    return True", 1.0], ["import string\n\ndef evaluate(response):\n    return not any(c in string.punctuation for c in response)", 1.0], ["import string\n\ndef evaluate(response):\n    for char in response:\n        if char in string.punctuation:\n            return False\n    return True", 1.0], ["import string\ndef evaluate(response):\n    punctuation = set(string.punctuation)\n    for char in response:\n        if char in punctuation:\n            return False\n    return True", 1.0]], "cases": [["Apostrophe isn't allowed", false], ["This has a comma, see?", false], ["Hello world", true], ["This is a test without punctuation", true], ["It's a test", false], ["Hyphenated-word here", false], ["Here is a comma, which is bad", false], ["I'm happy", false], ["Apostrophes aren't allowed", false], ["This sentence ends with a period.", false], ["Hello, world!", false], ["Avoiding all punctuation", true], ["I am happy", true], ["Hello! How are you?", false]]}
{"id": 39, "instruction": "Avoid using the letter 'A' in any word", "eval_func": [["def evaluate(response):\n    return 'a' not in response.lower()", 0.8888888888888888], ["def evaluate(response):\n    for word in response.split():\n        if 'A' in word or 'a' in word:\n            return False\n    return True", 0.8888888888888888]], "cases": [["Hello World", true], ["A valid response", false], ["Hello world!", true], ["Hello world", true], ["An example with A", false], ["This is a test", true], ["Testing without any", false], ["Banana split", false], ["Apple", false]]}
{"id": 40, "instruction": "Capitalize every other letter in the response", "eval_func": [["def evaluate(response):\n    letter_count = 0\n    for c in response:\n        if c.isalpha():\n            if letter_count % 2 == 0:\n                if not c.isupper():\n                    return False\n            else:\n                if not c.islower():\n                    return False\n            letter_count += 1\n    return True", 1.0], ["def evaluate(response):\n    next_upper = True\n    for c in response:\n        if c.isalpha():\n            if next_upper:\n                if not c.isupper():\n                    return False\n            else:\n                if not c.islower():\n                    return False\n            next_upper = not next_upper\n    return True", 1.0], ["def evaluate(response):\n    letter_count = 0\n    for c in response:\n        if c.isalpha():\n            if letter_count % 2 == 0:\n                if c != c.upper():\n                    return False\n            else:\n                if c != c.lower():\n                    return False\n            letter_count +=1\n    return True", 1.0], ["def evaluate(response):\n    letter_count = 0\n    for c in response:\n        if c.isalpha():\n            if letter_count % 2 == 0:\n                if c != c.upper():\n                    return False\n            else:\n                if c != c.lower():\n                    return False\n            letter_count += 1\n    return True", 1.0]], "cases": [["A!bC", true], ["AbcDef", false], ["AbcD", false], ["HeLlO wOrLd!", true], ["A!b", true], ["AbCd", true], ["H3aLLo", false], ["Hello", false], ["A1b!C", true], ["AbCdEf", true], ["A1b", true], ["Hello World", false], ["HeLlO", true]]}
{"id": 42, "instruction": "Each sentence must be a palindrome", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if not stripped:\n            continue\n        processed = re.sub(r'[^a-zA-Z0-9]', '', stripped).lower()\n        if processed != processed[::-1]:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        processed = ''.join(c for c in stripped if c.isalnum()).lower()\n        if processed != processed[::-1]:\n            return False\n    return True", 1.0]], "cases": [["Hello. abba.", false], ["Madam. Radar. Racecar.", true], ["A man, a plan, a canal: Panama. Madam.", true], ["A man, a plan, a canal: Panama!", true], ["Hello. World", false], ["Madam. Radar.", true]]}
{"id": 45, "instruction": "Each sentence must have a prime number of words", "eval_func": [["import re\n\ndef evaluate(response):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped:\n            word_count = len(stripped.split())\n            if not is_prime(word_count):\n                return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if not stripped:\n            continue\n        word_count = len(stripped.split())\n        if not is_prime(word_count):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) +1, 2):\n            if n % i ==0:\n                return False\n        return True\n    sentences = re.split(r'[.!?]', response)\n    for sent in sentences:\n        sent_stripped = sent.strip()\n        if not sent_stripped:\n            continue\n        word_count = len(sent_stripped.split())\n        if not is_prime(word_count):\n            return False\n    return True", 1.0], ["import re\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sent in sentences:\n        stripped = sent.strip()\n        if not stripped:\n            continue\n        words = stripped.split()\n        count = len(words)\n        if not is_prime(count):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped:\n            word_count = len(stripped.split())\n            if not is_prime(word_count):\n                return False\n    return True", 1.0]], "cases": [["Hi there! I am here.", true], ["Hello. How are you?", false], ["Hello world.", true], ["Hi. I am here.", false], ["I am. You are there.", true], ["Hello.", false], ["", true], ["I am. You are.", true], ["This has four words. Short one.", false]]}
{"id": 46, "instruction": "Each sentence must have exactly five words", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        words = line.strip().split()\n        if len(words) != 5:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.split('\\n')\n    for sentence in sentences:\n        words = sentence.split()\n        if len(words) != 5:\n            return False\n    return True", 1.0]], "cases": [["One two three four five\nSix seven eight nine ten", true], ["Five words here yes indeed\nBut this line has six words now", false], ["This is a five word sentence", false]]}
{"id": 47, "instruction": "Each sentence must have exactly seven words", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = [s.strip() for s in re.split(r'[.!?]', response) if s.strip()]\n    for sentence in sentences:\n        words = sentence.split()\n        if len(words) != 7:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sent in sentences:\n        stripped = sent.strip()\n        if stripped:\n            words = stripped.split()\n            if len(words) != 7:\n                return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.findall(r'[^.!?]+[.!?]', response)\n    for sent in sentences:\n        stripped = sent.strip()\n        words = stripped.split()\n        if len(words) != 7:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    sentences = re.split(r'[.!?]', response)\n    for sent in sentences:\n        stripped = sent.strip()\n        if not stripped:\n            continue\n        words = stripped.split()\n        if len(words) != 7:\n            return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sent in sentences:\n        sent_stripped = sent.strip()\n        if not sent_stripped:\n            continue\n        words = sent_stripped.split()\n        if len(words) != 7:\n            return False\n    return True", 1.0]], "cases": [["Short sentence. This is a longer sentence that has more than seven words.", false], ["Each of these seven words is correct. They all meet the requirement exactly! Right?", false], ["Short sentence. This one is too long with more than seven words.", false], ["", true], ["Short sentence. This one is okay but the first is not.", false], ["This sentence has exactly seven words here.", true], ["Hello my name is Sam and I.", true]]}
{"id": 48, "instruction": "Each sentence must start with the same letter", "eval_func": [["def evaluate(response):\n    import re\n    sentences = re.split(r'[.!?]\\s*', response.strip())\n    first_letters = []\n    for s in sentences:\n        s_stripped = s.strip()\n        if not s_stripped:\n            continue\n        first_letters.append(s_stripped[0])\n    if not first_letters:\n        return True\n    first_letter = first_letters[0]\n    for letter in first_letters[1:]:\n        if letter != first_letter:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]\\s*', response.strip())\n    sentences = [s for s in sentences if s]\n    if not sentences:\n        return True\n    first_letters = []\n    for s in sentences:\n        first_char = s[0]\n        if not first_char.isalpha():\n            return False\n        first_letters.append(first_char)\n    return len(set(first_letters)) == 1", 1.0], ["import re\ndef evaluate(response):\n    sentences = re.split(r'[.!?]\\s+', response.strip())\n    processed = [s.strip() for s in sentences if s.strip()]\n    if not processed:\n        return False\n    first_char = processed[0][0]\n    for sent in processed:\n        if sent[0] != first_char:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = [s.strip() for s in re.split(r'[.!?]\\s*', response.strip())]\n    sentences = [s for s in sentences if s]\n    if not sentences:\n        return False\n    first_letter = None\n    for sentence in sentences:\n        current = sentence[0].lower()\n        if first_letter is None:\n            first_letter = current\n        elif current != first_letter:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = [s.strip() for s in re.split(r'[.!?]', response) if s.strip()]\n    if not sentences:\n        return True\n    first_char = sentences[0][0]\n    for sent in sentences:\n        if sent[0] != first_char:\n            return False\n    return True", 1.0]], "cases": [["Always ask. Act accordingly. Agree always.", true], ["123. Test.", false], ["Hi! How are you? I'm here.", false], ["Apple. Banana.", false], ["Apple. Awesome.", true], ["Banana. cherry.", false]]}
{"id": 50, "instruction": "Each word must be a different color name", "eval_func": [["def evaluate(response):\n    color_names = {\n        'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure',\n        'beige', 'bisque', 'black', 'blanchedalmond', 'blue',\n        'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse',\n        'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson',\n        'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray',\n        'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta',\n        'darkolivegreen', 'darkorange', 'darkorchid', 'darkred',\n        'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray',\n        'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink',\n        'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick',\n        'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro',\n        'ghostwhite', 'gold', 'goldenrod', 'gray', 'green',\n        'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo',\n        'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen',\n        'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan',\n        'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey',\n        'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue',\n        'lightslategray', 'lightslategrey', 'lightsteelblue',\n        'lightyellow', 'lime', 'limegreen', 'linen', 'magenta',\n        'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid',\n        'mediumpurple', 'mediumseagreen', 'mediumslateblue',\n        'mediumspringgreen', 'mediumturquoise', 'mediumvioletred',\n        'midnightblue', 'mintcream', 'mistyrose', 'moccasin',\n        'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab',\n        'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen',\n        'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff',\n        'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple',\n        'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon',\n        'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver',\n        'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow',\n        'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato',\n        'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow',\n        'yellowgreen'\n    }\n    words = response.strip().split()\n    if not words:\n        return False\n    lower_words = []\n    for word in words:\n        lower_word = word.lower()\n        if lower_word not in color_names:\n            return False\n        lower_words.append(lower_word)\n    return len(lower_words) == len(set(lower_words))", 1.0], ["def evaluate(response):\n    valid_colors = {'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgrey', 'darkgreen', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'grey', 'green', 'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgrey', 'lightgreen', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'}\n    words = response.strip().split()\n    if not words:\n        return False\n    seen = set()\n    for word in words:\n        lower_word = word.lower()\n        if lower_word not in valid_colors:\n            return False\n        if lower_word in seen:\n            return False\n        seen.add(lower_word)\n    return True", 1.0], ["def evaluate(response):\n    valid_colors = {\n        'red', 'green', 'blue', 'yellow', 'black', 'white',\n        'orange', 'purple', 'pink', 'brown', 'gray', 'cyan',\n        'magenta', 'silver', 'gold', 'teal', 'lime', 'olive',\n        'navy', 'maroon', 'aqua', 'violet', 'indigo', 'coral',\n        'turquoise', 'lavender'\n    }\n    words = response.split()\n    seen = set()\n    for word in words:\n        lower_word = word.lower()\n        if lower_word not in valid_colors:\n            return False\n        if lower_word in seen:\n            return False\n        seen.add(lower_word)\n    return True", 1.0], ["def evaluate(response):\n    color_names = {'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'}\n    words = response.split()\n    return all(word in color_names for word in words) and len(words) == len(set(words))", 1.0]], "cases": [["apple banana", false], ["red green blue", true], ["red blue green", true], ["notacolor", false], ["red blue red", false], ["purple rainbow", false], ["Red blue red", false], ["red Red", false]]}
{"id": 53, "instruction": "Each word must be a different number (e.g., \"one,\" \"two\")", "eval_func": [["def evaluate(response):\n    number_words = {\n        'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten',\n        'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen',\n        'eighteen', 'nineteen', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy',\n        'eighty', 'ninety', 'hundred', 'thousand', 'million'\n    }\n    words = response.strip().split()\n    seen = set()\n    for word in words:\n        if word not in number_words or word in seen:\n            return False\n        seen.add(word)\n    return bool(words)", 1.0], ["def evaluate(response):\n    number_words = {'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety', 'hundred', 'thousand'}\n    words = response.split()\n    for word in words:\n        if word not in number_words:\n            return False\n    return len(words) == len(set(words))", 1.0], ["def evaluate(response):\n    number_words = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n                    \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n                    \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\", \"hundred\", \"thousand\", \"million\"}\n    words = response.split()\n    for word in words:\n        if word not in number_words:\n            return False\n    return len(words) == len(set(words))", 1.0], ["def evaluate(response):\n    number_words = {\n        'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten',\n        'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen',\n        'nineteen', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety',\n        'hundred', 'thousand', 'million', 'billion', 'trillion'\n    }\n    words = response.strip().split()\n    lower_words = []\n    for word in words:\n        lower_word = word.lower()\n        if lower_word not in number_words:\n            return False\n        lower_words.append(lower_word)\n    return len(lower_words) == len(set(lower_words))", 1.0], ["def evaluate(response):\n    number_words = {\n        'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten',\n        'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen', 'twenty',\n        'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety',\n        'hundred', 'thousand', 'million', 'billion'\n    }\n    words = response.strip().split()\n    for word in words:\n        if word not in number_words:\n            return False\n    return len(words) == len(set(words))", 1.0]], "cases": [["one one two", false], ["one two three", true], ["four five dog", false]]}
{"id": 56, "instruction": "End every sentence with a punctuation mark that's different from the previous", "eval_func": [["import re\n\ndef evaluate(response):\n    pattern = re.compile(r'([.!?])(?=\\s|$)')\n    matches = list(pattern.finditer(response))\n    punctuations = [m.group(1) for m in matches]\n    \n    if len(response.strip()) > 0:\n        if not matches:\n            return False\n        last_match = matches[-1]\n        end_pos = last_match.end()\n        remaining = response[end_pos:]\n        if remaining.strip() != '':\n            return False\n    \n    for i in range(1, len(punctuations)):\n        if punctuations[i] == punctuations[i-1]:\n            return False\n    \n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    parts = re.split('([.!?])', response)\n    punctuations = [p for p in parts[1::2] if p in ('.', '!', '?')]\n    for i in range(1, len(punctuations)):\n        if punctuations[i] == punctuations[i-1]:\n            return False\n    return True", 0.8], ["import re\ndef evaluate(response):\n    sequences = re.findall(r'[.!?]+', response)\n    if not sequences:\n        return False\n    last_puncts = [s[-1] for s in sequences]\n    for i in range(1, len(last_puncts)):\n        if last_puncts[i] == last_puncts[i-1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    endings = []\n    temp = []\n    for c in response:\n        if c in '.!?':\n            temp.append(c)\n        else:\n            if temp:\n                endings.append(temp[-1])\n                temp = []\n    if temp:\n        endings.append(temp[-1])\n    for i in range(1, len(endings)):\n        if endings[i] == endings[i-1]:\n            return False\n    return True", 0.8], ["import re\n\ndef evaluate(response):\n    if not response:\n        return False\n    if response[-1] not in ('.', '!', '?'):\n        return False\n    punctuations = re.findall(r'([.!?])(?=\\s+|$)', response)\n    if not punctuations:\n        return False\n    if punctuations[-1] != response[-1]:\n        return False\n    for i in range(1, len(punctuations)):\n        if punctuations[i] == punctuations[i-1]:\n            return False\n    return True", 1.0]], "cases": [["Hello. My name is Bob.", false], ["Hi! How are you?", true], ["This is a test", false], ["Wow! That's cool? Yes!", true], ["Yes! Yes! No.", false]]}
{"id": 57, "instruction": "Ensure each sentence is a different type (declarative, interrogative, etc.)", "eval_func": [["import re\ndef evaluate(response):\n    sentences = re.findall(r'[^.!?]*[.!?]', response)\n    sentences = [s.strip() for s in sentences if s.strip()]\n    types = []\n    for sent in sentences:\n        last_char = sent[-1]\n        if last_char == '.':\n            types.append('declarative')\n        elif last_char == '?':\n            types.append('interrogative')\n        elif last_char == '!':\n            types.append('exclamatory')\n    return len(types) == len(set(types))", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'(?<=[.!?])\\s+', response.strip())\n    types = []\n    for sent in sentences:\n        if not sent:\n            return False\n        last_char = sent[-1]\n        if last_char not in ('.', '!', '?'):\n            return False\n        types.append(last_char)\n    return len(types) == len(set(types)) and len(types) > 0", 1.0], ["def evaluate(response):\n    import re\n    sentences = re.findall(r'[^.!?]*[.!?]', response.strip())\n    types = []\n    for sent in sentences:\n        sent = sent.strip()\n        if not sent:\n            continue\n        last_char = sent[-1]\n        if last_char not in ('.', '?', '!'):\n            return False\n        types.append(last_char)\n    return len(types) == len(set(types)) and len(types) > 0", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.findall(r'([^.!?]+[.!?])', response)\n    types = []\n    for sent in sentences:\n        sent = sent.strip()\n        if not sent:\n            continue\n        last_char = sent[-1]\n        if last_char == '.':\n            types.append('declarative')\n        elif last_char == '?':\n            types.append('interrogative')\n        elif last_char == '!':\n            types.append('exclamatory')\n        else:\n            return False\n    for i in range(1, len(types)):\n        if types[i] == types[i-1]:\n            return False\n    return True", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'(?<=[.!?])\\s*(?=[A-Z]|$)', response)\n    sentences = [s.strip() for s in sentences if s.strip()]\n    types = []\n    for sent in sentences:\n        if not sent:\n            continue\n        last_char = sent[-1]\n        if last_char == '.':\n            types.append('declarative')\n        elif last_char == '?':\n            types.append('interrogative')\n        elif last_char == '!':\n            types.append('exclamatory')\n        else:\n            return False\n    return len(types) == len(set(types))", 1.0]], "cases": [["Hello! How are you? That's great.", true], ["Hello? World!", true], ["This is a test. Another test.", false], ["Hello. How are you. Bye.", false], ["This is a test.", true], ["Hi", false]]}
{"id": 58, "instruction": "Ensure each word is a palindrome and has an even number of letters", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) % 2 != 0:\n            return False\n        if word != word[::-1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if word != word[::-1] or len(word) % 2 != 0:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) % 2 != 0 or word != word[::-1]:\n            return False\n    return True", 1.0]], "cases": [["racecar madam", false], ["", true], ["abba nooN", false], ["noon nooN", false], ["abba noon", true]]}
{"id": 61, "instruction": "Every sentence must start with a consecutive letter of the alphabet", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    if sentences and sentences[-1].strip() == '':\n        sentences.pop()\n    expected_char = 'A'\n    for part in sentences:\n        stripped = part.strip()\n        if not stripped:\n            return False\n        first_char = stripped[0].upper()\n        if first_char != expected_char:\n            return False\n        expected_char = chr(ord(expected_char) + 1)\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'(?<=[.!?])\\s+(?=[A-Z])', response.strip())\n    expected_char = 'A'\n    for sentence in sentences:\n        stripped = sentence.lstrip()\n        if not stripped:\n            return False\n        first_char = stripped[0].upper()\n        if first_char != expected_char:\n            return False\n        expected_char = chr(ord(expected_char) + 1)\n        if ord(expected_char) > ord('Z'):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]\\s*', response.strip())\n    sentences = [s.strip() for s in sentences if s.strip()]\n    expected_ord = ord('A')\n    for idx, sentence in enumerate(sentences):\n        stripped = sentence.lstrip()\n        if not stripped:\n            return False\n        first_char = stripped[0].upper()\n        if not first_char.isalpha():\n            return False\n        current_ord = ord(first_char)\n        if current_ord != expected_ord:\n            return False\n        expected_ord += 1\n        if expected_ord > ord('Z') and idx < len(sentences) - 1:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'(?<=[.!?])\\s+(?=[A-Z])', response)\n    for idx, sent in enumerate(sentences):\n        if not sent:\n            return False\n        first_char = sent[0]\n        expected_ord = ord('A') + idx\n        if not first_char.isupper() or ord(first_char) != expected_ord:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    expected_char = 'a'\n    sentences = response.split('. ')\n    for sent in sentences:\n        if expected_char > 'z':\n            return False\n        sent_stripped = sent.lstrip()\n        if not sent_stripped:\n            return False\n        first_char = sent_stripped[0].lower()\n        if first_char != expected_char:\n            return False\n        expected_char = chr(ord(expected_char) + 1)\n    return True", 1.0]], "cases": [["A. C. D.", false], ["A. B. C.", true], ["Hello world.", false], ["A! B? C.", true]]}
{"id": 62, "instruction": "Every word must contain at least two vowels", "eval_func": [["def evaluate(response):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    for word in response.split():\n        count = 0\n        for char in word:\n            if char.lower() in vowels:\n                count += 1\n                if count >= 2:\n                    break\n        if count < 2:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    words = response.split()\n    for word in words:\n        count = 0\n        for char in word.lower():\n            if char in vowels:\n                count += 1\n        if count < 2:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    for word in response.split():\n        count = 0\n        for c in word.lower():\n            if c in vowels:\n                count += 1\n                if count >= 2:\n                    break\n        if count < 2:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    for word in response.split():\n        if sum(1 for c in word.lower() if c in vowels) < 2:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    for word in response.split():\n        count = 0\n        for char in word.lower():\n            if char in vowels:\n                count +=1\n        if count < 2:\n            return False\n    return True", 1.0]], "cases": [["test", false], ["correct example", true], ["Test code", false], ["Correct answer", true], ["hello world", false], ["Apple banana", true]]}
{"id": 63, "instruction": "Exclude the letter 'I' in all words", "eval_func": [["def evaluate(response):\n    return 'I' not in ' '.join(response.split())", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if 'I' in word:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    for word in response.split():\n        if 'I' in word:\n            return False\n    return True", 1.0]], "cases": [["Hello world", true], ["Learning AI is fun", false], ["Hiking with friends", true], ["I am here", false], ["Hiking is fun", true]]}
{"id": 67, "instruction": "Include the words \"would,\" \"could,\" or \"might\" in every sentence", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped:\n            if not re.search(r'\\b(would|could|might)\\b', stripped, re.IGNORECASE):\n                return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = [s.strip() for s in re.split(r'[.!?]', response) if s.strip()]\n    for sentence in sentences:\n        sentence_lower = sentence.lower()\n        if ('would' not in sentence_lower) and ('could' not in sentence_lower) and ('might' not in sentence_lower):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]+\\s*', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped and not re.search(r'\\b(would|could|might)\\b', stripped, re.IGNORECASE):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if not stripped:\n            continue\n        lower_sentence = stripped.lower()\n        if 'would' not in lower_sentence and 'could' not in lower_sentence and 'might' not in lower_sentence:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]+\\s*', response)\n    sentences = [s.strip() for s in sentences if s.strip()]\n    for sentence in sentences:\n        if not re.search(r'\\b(would|could|might)\\b', sentence, re.IGNORECASE):\n            return False\n    return True", 1.0]], "cases": [["I would go. He might come. She could stay.", true], ["He could try. She will help.", false], ["Would you go? She might agree.", true], ["It might rain. The weather is nice. We could go out.", false], ["Might this work? It would. Could it be?", true], ["MIGHT this be enough? Yes, it COULD!", true]]}
{"id": 70, "instruction": "Start each sentence with a vowel", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]\\s*', response)\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if stripped:\n            first_char = stripped[0].upper()\n            if first_char not in vowels:\n                return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'(?<=[.!?])\\s+', response.strip())\n    for sentence in sentences:\n        stripped = sentence.lstrip()\n        if not stripped:\n            return False\n        first_char = stripped[0].lower()\n        if first_char not in {'a', 'e', 'i', 'o', 'u'}:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    sentences = re.split(r'[.!?]\\s*', response)\n    for sentence in sentences:\n        stripped = sentence.lstrip()\n        if not stripped:\n            continue\n        first_char = stripped[0].lower()\n        if first_char not in vowels:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    for sent in sentences:\n        sent_stripped = sent.strip()\n        if not sent_stripped:\n            continue\n        first_char = sent_stripped[0].lower()\n        if first_char not in {'a', 'e', 'i', 'o', 'u'}:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]\\s*', response.strip())\n    sentences = [s for s in sentences if s]\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if not stripped:\n            return False\n        first_char = stripped[0].lower()\n        if first_char not in {'a', 'e', 'i', 'o', 'u'}:\n            return False\n    return True", 1.0]], "cases": [["A. E. I. O. U.", true], ["Apple. Elephant.", true], ["Banana. Apple.", false]]}
{"id": 71, "instruction": "Start every sentence with the same letter", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]\\s*', response.strip())\n    first_letter = None\n    for sent in sentences:\n        sent_stripped = sent.strip()\n        if not sent_stripped:\n            continue\n        current_char = sent_stripped[0]\n        if first_letter is None:\n            first_letter = current_char\n        elif current_char != first_letter:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    sentences = re.split(r'[.!?](?:\\s+|$)', response.strip())\n    first_char = None\n    for sent in sentences:\n        sent = sent.strip()\n        if not sent:\n            continue\n        if first_char is None:\n            first_char = sent[0]\n        else:\n            if sent[0] != first_char:\n                return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    sentences = re.split(r'[.!?]', response)\n    first_letter = None\n    for sent in sentences:\n        sent_stripped = sent.strip()\n        if not sent_stripped:\n            continue\n        current_char = sent_stripped[0]\n        if first_letter is None:\n            first_letter = current_char\n        else:\n            if current_char != first_letter:\n                return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = [s.strip() for s in re.split(r'[.!?]', response)]\n    sentences = [s for s in sentences if s]\n    if not sentences:\n        return True\n    first_char = None\n    for sent in sentences:\n        if not sent[0].isalpha():\n            return False\n        current_char = sent[0]\n        if first_char is None:\n            first_char = current_char\n        elif current_char != first_char:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    sentences = re.split(r'[.!?]\\s*', response)\n    sentences = [s.strip() for s in sentences if s.strip()]\n    if not sentences:\n        return False\n    first_char = None\n    for sent in sentences:\n        if not sent[0].isalpha():\n            return False\n        current_char = sent[0].lower()\n        if first_char is None:\n            first_char = current_char\n        elif current_char != first_char:\n            return False\n    return True", 0.8888888888888888]], "cases": [["Apple. Berry. Cherry.", false], ["Banana. Cherry. Date.", false], ["Charlie can cook. 3 chefs can't.", false], ["Bananas are blue. Oranges are orange.", false], ["Apple. Ant. Awesome.", true], ["Hi! How are you?", true], ["test. Test. tEST.", false], ["All agree. Always start right.", true], ["Apple always arrives. Awesome apples abound.", true]]}
{"id": 72, "instruction": "Use conditional perfect tense verbs (e.g., \"would have won\")", "eval_func": [["import re\n\ndef evaluate(response):\n    pattern = r'\\b(would|could|might|should)\\s+have\\s+\\w+'\n    return bool(re.search(pattern, response, re.IGNORECASE))", 1.0]], "cases": [["The team played well but lost the game.", false], ["We could have taken the earlier train.", true], ["She would have arrived on time if there was no traffic.", true]]}
{"id": 73, "instruction": "Use future continuous tense verbs (e.g., \"will be going\")", "eval_func": [["import re\n\ndef evaluate(response):\n    pattern = re.compile(r'\\b(will|\\'ll) be (\\w+ )*\\w+ing\\b', re.IGNORECASE)\n    return bool(pattern.search(response))", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r\"\\b(will|'ll)\\s+be\\s+(\\S+\\s+)*\\w+ing\\b\"\n    return bool(re.search(pattern, response, re.IGNORECASE))", 1.0], ["import re\n\ndef evaluate(response):\n    correct_pattern = re.compile(r'\\b(will|\\'ll)\\s+be\\s+.*?\\b\\w+ing\\b', re.IGNORECASE)\n    if not correct_pattern.search(response):\n        return False\n    incorrect_pattern = re.compile(r'\\b(will|\\'ll)\\s+(?!be\\s+.*?\\b\\w+ing\\b)\\w+', re.IGNORECASE)\n    if incorrect_pattern.search(response):\n        return False\n    return True", 1.0]], "cases": [["She will be going to the market.", true], ["They'll be traveling soon.", true], ["He'll be arriving at noon.", true], ["They are going to the park tomorrow.", false], ["She will be studying all night.", true], ["He is eating dinner.", false]]}
{"id": 75, "instruction": "Use only abbreviations (e.g., \"ASAP,\" \"RSVP\")", "eval_func": [["import string\n\ndef evaluate(response):\n    for word in response.split():\n        stripped = word.rstrip(string.punctuation)\n        if not stripped:\n            return False\n        if not stripped.isupper() or not any(c.isalpha() for c in stripped):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r'^[A-Z0-9]{2,}[!?,.:;]*$'\n    for word in response.split():\n        if not re.fullmatch(pattern, word):\n            return False\n    return True", 0.8888888888888888], ["import string\n\ndef evaluate(response):\n    words = response.split()\n    for word in words:\n        stripped_word = word.strip(string.punctuation)\n        if not stripped_word.isupper() or not stripped_word.isalpha():\n            return False\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    pattern = re.compile(r'^[A-Z]{2,}[^a-z]*$')\n    for token in response.split():\n        if not pattern.fullmatch(token):\n            return False\n    return True", 0.8888888888888888]], "cases": [["FYI TTYL!", true], ["ASAP, RSVP!", true], ["ASAP, but", false], ["ASAP, but...", false], ["ASAP RSVP", true], ["Please RSVP ASAP", false], ["F15 2FA!", true], ["FYI 123", false], ["ASap", false]]}
{"id": 76, "instruction": "Use only anagrams of the word 'listen'", "eval_func": [["def evaluate(response):\n    target = 'listen'\n    target_sorted = sorted(target)\n    words = response.lower().split()\n    if not words:\n        return False\n    for word in words:\n        if len(word) != len(target) or sorted(word) != target_sorted:\n            return False\n    return True", 0.9], ["def evaluate(response):\n    required = sorted('listen')\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if len(word) != 6 or sorted(word.lower()) != required:\n            return False\n    return True", 0.9], ["def evaluate(response):\n    expected = sorted('listen')\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if len(word) != 6 or sorted(word.lower()) != expected:\n            return False\n    return True", 0.9], ["def evaluate(response):\n    target = sorted('listen')\n    words = response.split()\n    for word in words:\n        if sorted(word.lower()) != target:\n            return False\n    return True", 1.0]], "cases": [["listen please", false], ["listens", false], ["enlist tinsel", true], ["Listen tinsel", true], ["", true], ["silent", true], ["listen test", false], ["EnLiSt", true], ["silent enlist tinsel", true], ["Listen", true]]}
{"id": 77, "instruction": "Use only animal names as words", "eval_func": [["def evaluate(response):\n    animal_names = {'cat', 'dog', 'elephant', 'lion', 'tiger', 'zebra', 'giraffe', 'monkey', 'kangaroo', 'rhino', 'penguin', 'bear', 'wolf', 'fox', 'deer', 'cow', 'horse', 'sheep', 'goat', 'pig', 'chicken', 'duck', 'eagle', 'shark', 'dolphin', 'whale', 'octopus', 'rabbit', 'mouse', 'rat', 'snake', 'frog', 'turtle', 'bat', 'bee', 'ant', 'spider', 'fish', 'owl', 'parrot', 'crow', 'swan', 'crocodile', 'lizard', 'hamster', 'gorilla', 'buffalo', 'camel', 'cheetah', 'hyena', 'koala', 'leopard', 'panda', 'raccoon', 'seal', 'skunk', 'squirrel', 'walrus', 'ostrich', 'peacock', 'flamingo', 'toucan', 'alligator', 'jaguar', 'moose', 'sloth', 'armadillo', 'hedgehog', 'lemur', 'llama', 'mole', 'otter', 'porcupine', 'possum', 'reindeer', 'salamander', 'weasel', 'wombat', 'yak'}\n    words = response.split()\n    for word in words:\n        if word.lower() not in animal_names:\n            return False\n    return True", 0.9230769230769231], ["def evaluate(response):\n    animals = {'cat', 'dog', 'elephant', 'lion', 'tiger', 'bear', 'wolf', 'zebra', 'monkey', 'giraffe'}\n    words = response.strip().split()\n    for word in words:\n        if word.lower() not in animals:\n            return False\n    return True", 0.9230769230769231], ["def evaluate(response):\n    animals = {\n        'cat', 'dog', 'elephant', 'lion', 'tiger', 'zebra', 'giraffe',\n        'monkey', 'bear', 'wolf', 'fox', 'kangaroo', 'penguin', 'rhinoceros',\n        'hippopotamus', 'crocodile', 'dolphin', 'whale', 'shark', 'eagle',\n        'owl', 'parrot', 'sparrow', 'pigeon', 'snake', 'lizard', 'turtle',\n        'frog', 'toad', 'fish', 'salmon', 'trout', 'octopus', 'crab', 'lobster',\n        'ant', 'bee', 'butterfly', 'mosquito', 'fly', 'spider', 'scorpion',\n        'horse', 'cow', 'sheep', 'goat', 'pig', 'chicken', 'duck', 'turkey',\n        'rabbit', 'hamster', 'mouse', 'rat', 'deer', 'moose', 'buffalo',\n        'koala', 'panda', 'sloth', 'otter', 'seal', 'walrus', 'cheetah',\n        'leopard', 'jaguar', 'hyena', 'coyote', 'meerkat', 'wombat', 'platypus',\n        'armadillo', 'raccoon', 'skunk', 'squirrel', 'beaver', 'chimpanzee',\n        'gorilla', 'orangutan', 'bonobo', 'lemur', 'gazelle', 'antelope',\n        'caribou', 'elk', 'llama', 'alpaca', 'camel', 'ostrich', 'peacock',\n        'flamingo', 'swan', 'goose', 'pelican', 'cormorant', 'starfish',\n        'jellyfish', 'clownfish', 'goldfish', 'tuna', 'seahorse', 'ray',\n        'urchin', 'anemone', 'alligator', 'gecko', 'chameleon', 'iguana',\n        'komodo', 'python', 'cobra', 'viper', 'rattlesnake', 'boa', 'anaconda',\n        'tortoise', 'terrapin', 'salamander', 'newt', 'axolotl'\n    }\n    words = response.split()\n    for word in words:\n        if word.lower() not in animals:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    animal_names = {\n        'cat', 'dog', 'elephant', 'lion', 'tiger', 'zebra', 'giraffe',\n        'monkey', 'bear', 'wolf', 'fox', 'kangaroo', 'penguin', 'whale',\n        'shark', 'dolphin', 'octopus', 'rhinoceros', 'hippopotamus',\n        'crocodile', 'snake', 'eagle', 'hawk', 'sparrow', 'owl', 'parrot',\n        'falcon', 'ostrich', 'peacock', 'pigeon', 'crow', 'robin', 'swan',\n        'duck', 'goose', 'chicken', 'turkey', 'cow', 'horse', 'pig', 'sheep',\n        'goat', 'rabbit', 'deer', 'moose', 'buffalo', 'antelope', 'gazelle',\n        'cheetah', 'leopard', 'jaguar', 'hyena', 'panda', 'koala', 'sloth',\n        'armadillo', 'raccoon', 'skunk', 'beaver', 'otter', 'seal', 'walrus',\n        'squirrel', 'chipmunk', 'porcupine', 'bat', 'rat', 'mouse', 'hamster',\n        'gerbil', 'ferret', 'llama', 'alpaca', 'camel', 'donkey', 'mule', 'ox',\n        'yak', 'reindeer', 'caribou', 'bison', 'ant', 'bee', 'butterfly',\n        'spider', 'scorpion', 'beetle', 'grasshopper', 'cricket', 'ladybug',\n        'mosquito', 'fly', 'dragonfly', 'centipede', 'millipede', 'worm',\n        'snail', 'slug', 'jellyfish', 'starfish', 'seahorse', 'lobster', 'crab',\n        'shrimp', 'clownfish', 'salmon', 'tuna', 'goldfish', 'carp', 'trout',\n        'catfish', 'stingray', 'squid', 'cuttlefish', 'turtle', 'frog', 'toad',\n        'salamander', 'newt', 'alligator', 'iguana', 'chameleon', 'gecko',\n        'lizard', 'cobra', 'viper', 'python', 'anaconda', 'boa', 'condor',\n        'vulture', 'woodpecker', 'hummingbird', 'flamingo', 'pelican',\n        'albatross', 'raven', 'magpie', 'bluejay', 'canary', 'finch', 'toucan',\n        'kiwi', 'emu', 'lorikeet', 'cockatoo', 'macaw', 'swallow', 'tern',\n        'gull', 'heron', 'crane', 'stork', 'ibis', 'spoonbill', 'kingfisher',\n        'hoopoe', 'quail', 'partridge', 'pheasant', 'grouse', 'ptarmigan',\n        'sandpiper', 'plover', 'curlew', 'snipe', 'woodcock', 'grebe', 'loon',\n        'auk', 'puffin', 'guillemot', 'razorbill', 'skua', 'jaeger', 'petrel',\n        'shearwater', 'gannet', 'cormorant', 'frigatebird', 'booby',\n        'tropicbird', 'osprey', 'kite', 'harrier', 'buzzard', 'kestrel',\n        'merlin', 'peregrine', 'goshawk', 'sparrowhawk', 'hobby', 'saker',\n        'eagleowl', 'puma', 'cougar', 'lynx', 'ocelot', 'serval', 'caracal',\n        'manatee', 'dugong', 'sealion', 'narwhal', 'beluga', 'orca', 'humpback',\n        'spermwhale', 'bluewhale', 'minke', 'rightwhale', 'bowhead', 'graywhale',\n        'porpoise', 'tapir', 'okapi', 'bongo', 'eland', 'kudu', 'nyala', 'sable',\n        'oryx', 'addax', 'impala', 'springbok', 'waterbuck', 'reedbuck', 'topi',\n        'hartebeest', 'wildebeest', 'gnu', 'muskox', 'ibex', 'markhor', 'tahr',\n        'chamois', 'argali', 'bighorn', 'mouflon', 'urial', 'goral', 'serow',\n        'takin', 'saiga', 'nilgai', 'blackbuck', 'chinkara', 'fourhorned',\n        'pronghorn', 'gemsbok', 'roan', 'sitatunga', 'lechwe', 'puku', 'kob',\n        'defassa', 'bushbuck'\n    }\n    words = response.split()\n    for word in words:\n        if word.lower() not in animal_names:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    animals = {'cat', 'dog', 'elephant', 'lion', 'tiger', 'bear', 'wolf', 'fox', 'deer', 'rabbit', 'zebra', 'giraffe', 'monkey', 'kangaroo', 'penguin', 'whale', 'shark', 'eagle', 'snake', 'crocodile', 'rhino', 'frog', 'horse', 'cow', 'sheep', 'goat', 'pig', 'chicken', 'duck', 'goose', 'turkey', 'mouse', 'rat', 'parrot', 'owl', 'dolphin', 'seal', 'lobster', 'crab', 'ant', 'bee', 'butterfly', 'spider', 'scorpion', 'octopus', 'panda', 'koala', 'hyena', 'gorilla', 'cheetah', 'leopard', 'moose', 'squirrel', 'raccoon', 'buffalo', 'camel', 'llama', 'alpaca', 'peacock', 'swan', 'flamingo', 'pelican', 'toucan', 'jellyfish', 'starfish', 'seahorse', 'squid', 'shrimp', 'salmon', 'trout', 'tuna', 'cod', 'clownfish', 'snail', 'slug', 'ladybug', 'dragonfly', 'mosquito', 'fly', 'wasp', 'cricket', 'firefly', 'pigeon', 'crow', 'raven', 'hawk', 'vulture', 'falcon', 'bat', 'toad', 'turtle', 'tortoise', 'iguana', 'chameleon', 'gecko', 'komodo', 'anaconda', 'python', 'cobra', 'viper', 'rattlesnake', 'boa', 'walrus', 'manatee', 'otter', 'platypus', 'wombat', 'armadillo', 'porcupine', 'skunk', 'badger', 'mole', 'hedgehog', 'meerkat', 'lemur', 'sloth', 'antelope', 'bison', 'elk', 'reindeer', 'yak', 'lynx', 'cougar', 'panther', 'jaguar', 'hippo', 'hippopotamus', 'gazelle', 'wildebeest', 'gnu'}\n    words = response.split()\n    for word in words:\n        if word.lower() not in animals:\n            return False\n    return True", 1.0]], "cases": [["apple banana", false], ["ELEPHANT", true], ["Python", true], ["cat dog", true], ["apple bear", false], ["Lion Elephant", true], ["Tiger", true], ["Elephant monkey car", false], ["apple tiger", false], ["Dog tree", false], ["Zebra123", false], ["cat", true], ["Elephant", true]]}
{"id": 78, "instruction": "Use only color names as words", "eval_func": [["def evaluate(response):\n    color_names = {'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'}\n    words = response.split()\n    for word in words:\n        if word.lower() not in color_names:\n            return False\n    return True", 0.875], ["def evaluate(response):\n    color_names = {\n        'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black',\n        'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse',\n        'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan',\n        'darkgoldenrod', 'darkgray', 'darkgrey', 'darkgreen', 'darkkhaki', 'darkmagenta',\n        'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen',\n        'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink',\n        'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen',\n        'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'grey', 'green',\n        'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender',\n        'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan',\n        'lightgoldenrodyellow', 'lightgray', 'lightgrey', 'lightgreen', 'lightpink', 'lightsalmon',\n        'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue',\n        'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine',\n        'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue',\n        'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream',\n        'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange',\n        'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred',\n        'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple',\n        'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen',\n        'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow',\n        'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet',\n        'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'\n    }\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if word.lower() not in color_names:\n            return False\n    return True", 0.875], ["def evaluate(response):\n    valid_colors = {'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'}\n    words = response.split()\n    for word in words:\n        if word.lower() not in valid_colors:\n            return False\n    return True", 0.875]], "cases": [["Red", false], ["red blue green", true], ["Navy", true], ["Blue123", false], ["red blue", true], ["Magenta Cyan", true], ["blue123", false], ["apple", false]]}
{"id": 79, "instruction": "Use only continuous tense verbs (ending with \"-ing\")", "eval_func": [["import string\n\ndef evaluate(response):\n    for word in response.split():\n        stripped = word.strip(string.punctuation)\n        if stripped and not stripped.endswith('ing'):\n            return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    words = re.findall(r'\\b\\w+\\b', response.lower())\n    for word in words:\n        if not word.endswith('ing'):\n            return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    # Split into words, considering possible punctuation\n    words = re.findall(r'\\b\\w+\\b', response.lower())\n    # Common non-continuous verbs (base form and others)\n    non_continuous_verbs = {'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being',\n                            'have', 'has', 'had', 'do', 'does', 'did', 'shall', 'will',\n                            'should', 'would', 'may', 'might', 'must', 'can', 'could'}\n    for word in words:\n        if word in non_continuous_verbs or (len(word) > 3 and not word.endswith('ing') and word not in non_continuous_verbs):\n            # Check if the word could be a verb not in continuous form\n            # This is a heuristic and may not cover all cases\n            return False\n    return True", 0.8]], "cases": [["Running and jumping", false], ["Running quickly to catch the bus, panting heavily.", false], ["Swimming, dancing, singing", true], ["She is singing while walking in the park.", false], ["She is singing", false]]}
{"id": 80, "instruction": "Use only contractions (e.g., \"don’t,\" \"can’t\")", "eval_func": [["def evaluate(response):\n    for word in response.split():\n        if \"'\" not in word and '’' not in word:\n            return False\n    return True", 0.8571428571428571]], "cases": [["Don’t worry, they’ll be here soon.", true], ["don't!", true], ["I can't do it", false], ["She said we will go", false], ["She's happy but he is sad.", false], ["don't can’t won’t", true], ["", true], ["don't you know it's time", true], ["I do not like apples.", false], ["I cannot believe it's not butter", false], ["don't can't", true], ["you're", true], ["I can't believe it", false], ["I can't", false]]}
{"id": 82, "instruction": "Use only future tense verbs (e.g., \"will go\")", "eval_func": [["import re\n\ndef evaluate(response):\n    expanded = re.sub(r\"(\\w+)'ll\\b\", r\"\\1 will\", response, flags=re.IGNORECASE)\n    present_aux = re.search(r'\\b(am|is|are|has|have|do|does)\\b', expanded, re.IGNORECASE)\n    if present_aux:\n        return False\n    past_aux = re.search(r'\\b(was|were|had|did)\\b', expanded, re.IGNORECASE)\n    if past_aux:\n        return False\n    past_ed = re.search(r'\\b\\w+ed\\b', expanded)\n    if past_ed:\n        return False\n    irregular_past = re.search(r'\\b(went|ate|ran|saw|gave|took|made)\\b', expanded, re.IGNORECASE)\n    if irregular_past:\n        return False\n    third_person = re.search(r'\\b(he|she|it)\\s+\\w+s\\b', expanded, re.IGNORECASE)\n    if third_person:\n        return False\n    if not re.search(r'\\bwill\\s+\\w+', expanded, re.IGNORECASE):\n        return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    words = response.lower().split()\n    irregular_past = {'went', 'ate', 'saw', 'came', 'did', 'made', 'took', 'had', 'was', 'were', 'been', 'became', 'began', 'broke', 'brought', 'built', 'bought', 'caught', 'chose', 'drank', 'drove', 'fell', 'felt', 'found', 'flew', 'forgot', 'gave', 'got', 'grew', 'heard', 'hit', 'held', 'kept', 'knew', 'led', 'left', 'lost', 'met', 'paid', 'put', 'read', 'rode', 'ran', 'said', 'sang', 'sat', 'slept', 'spoke', 'stood', 'swam', 'took', 'taught', 'told', 'thought', 'understood', 'wore', 'wrote'}\n    for i in range(len(words)):\n        if words[i] == 'will':\n            if i + 1 >= len(words):\n                return False\n            next_word = re.sub(r'[^a-z]', '', words[i+1].lower())\n            if next_word in irregular_past or next_word.endswith(('ed', 'd', 's', 'ing')):\n                return False\n    for i in range(len(words)):\n        word = re.sub(r'[^a-z]', '', words[i].lower())\n        if word in irregular_past or word.endswith(('ed', 'd', 's', 'ing')):\n            if i == 0 or words[i-1].lower() != 'will':\n                return False\n    return True", 0.8], ["def evaluate(response):\n    if 'will' not in response.lower().split():\n        return False\n    words = response.lower().split()\n    for word in words:\n        if word.endswith('s'):\n            return False\n    for word in words:\n        if word.endswith('ed'):\n            return False\n    irregular_past = {'ate', 'went', 'came', 'saw', 'ran', 'drank', 'spoke', 'wrote', 'broke', 'drove', 'fell', 'bit', 'chose', 'drew'}\n    for word in words:\n        if word in irregular_past:\n            return False\n    return True", 0.8], ["import re\n\ndef evaluate(response):\n    lower_response = response.lower()\n    words = re.findall(r'\\b\\w+\\b', lower_response)\n    future_aux = False\n    for i in range(len(words)):\n        word = words[i]\n        if word in ['will', 'shall']:\n            future_aux = True\n            if i == len(words)-1:\n                return False\n            next_word = words[i+1]\n            if next_word.endswith(('s', 'ed', 'ing')):\n                return False\n        elif word in ['went', 'ate', 'ran', 'saw', 'did', 'had', 'made', 'came', 'took', 'found']:\n            return False\n        elif re.search(r'(s|ed|ing)\\b', word):\n            return False\n    return future_aux", 0.8], ["def evaluate(response):\n    forbidden_words = {'goes', 'went', 'walked', 'is', 'are', 'was', 'were', 'am', 'ran', 'ate', 'did', 'has', 'have', 'do', 'does'}\n    words = [word.lower().strip('.,?!') for word in response.split()]\n    for word in words:\n        if word in forbidden_words:\n            return False\n        if word.endswith('ed'):\n            return False\n        if len(word) > 2 and word.endswith('s') and not word.endswith(('ss', 'us', 'is', 'ous')):\n            return False\n    return True", 1.0]], "cases": [["They will arrive tomorrow.", true], ["He will went home early.", false], ["She eats breakfast.", false], ["He'll visit his friend.", true], ["She eats an apple.", false]]}
{"id": 83, "instruction": "Use only geometric shape names (e.g., \"circle,\" \"cube\")", "eval_func": [["import re\n\ndef evaluate(response):\n    allowed_shapes = {\n        'circle', 'square', 'triangle', 'rectangle', 'pentagon', 'hexagon', \n        'octagon', 'ellipse', 'oval', 'rhombus', 'trapezoid', 'parallelogram', \n        'kite', 'polygon', 'semicircle', 'crescent', 'star', 'cube', 'sphere', \n        'cylinder', 'cone', 'pyramid', 'prism', 'tetrahedron', 'octahedron', \n        'dodecahedron', 'icosahedron', 'cuboid', 'torus', 'ellipsoid', \n        'hemisphere'\n    }\n    words = re.findall(r'\\b\\w+\\b', response.lower())\n    return all(word in allowed_shapes for word in words)", 1.0], ["def evaluate(response):\n    allowed = {'circle', 'square', 'triangle', 'rectangle', 'pentagon', 'hexagon', 'oval', 'ellipse', 'rhombus', 'trapezoid', 'cube', 'sphere', 'cylinder', 'cone', 'pyramid', 'prism', 'tetrahedron', 'octahedron', 'dodecahedron', 'polygon', 'star', 'crescent', 'cuboid', 'hemisphere', 'octagon', 'parallelogram', 'kite', 'decagon', 'icosagon', 'torus'}\n    words = response.split()\n    for word in words:\n        if word.lower() not in allowed:\n            return False\n    return True", 0.875], ["def evaluate(response):\n    allowed_shapes = {'circle', 'square', 'triangle', 'rectangle', 'oval', 'ellipse', 'pentagon', 'hexagon', 'octagon', 'rhombus', 'trapezoid', 'parallelogram', 'cube', 'sphere', 'cylinder', 'cone', 'pyramid', 'prism', 'tetrahedron', 'octahedron', 'dodecahedron', 'icosahedron', 'torus', 'polygon', 'quadrilateral', 'semicircle', 'hemisphere', 'cuboid', 'star', 'crescent', 'kite', 'diamond', 'frustum', 'annulus', 'ring', 'ellipsoid'}\n    tokens = response.replace(',', ' ').split()\n    for token in tokens:\n        if token.strip().lower() not in allowed_shapes:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    allowed_shapes = {\n        'circle', 'square', 'triangle', 'rectangle', 'oval', 'ellipse',\n        'pentagon', 'hexagon', 'octagon', 'rhombus', 'trapezoid', 'parallelogram',\n        'cube', 'sphere', 'cylinder', 'cone', 'pyramid', 'prism', 'tetrahedron',\n        'octahedron', 'dodecahedron', 'icosahedron', 'polygon', 'star', 'crescent',\n        'hemisphere', 'cuboid', 'torus', 'kite', 'diamond', 'cylinder', 'semicircle',\n        'polyhedron', 'sphere', 'octagon', 'decagon', 'nonagon', 'heptagon',\n        'parallelogram', 'rhombus', 'trapezium', 'quadrilateral', 'pentagram',\n        'hexagram', 'ellipsoid', 'prism', 'antiprism', 'frustum'\n    }\n    words = re.findall(r'\\b[a-zA-Z]+\\b', response.lower())\n    if not words:\n        return False\n    for word in words:\n        if word not in allowed_shapes:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    valid_shapes = {\n        \"circle\", \"square\", \"triangle\", \"rectangle\", \"cube\", \"sphere\",\n        \"cylinder\", \"pyramid\", \"cone\", \"prism\", \"polygon\", \"pentagon\",\n        \"hexagon\", \"octagon\", \"oval\", \"ellipse\", \"rhombus\", \"trapezoid\",\n        \"parallelogram\", \"semicircle\", \"crescent\", \"star\", \"kite\", \"cuboid\",\n        \"hemisphere\", \"torus\", \"ellipsoid\", \"dodecahedron\", \"octahedron\",\n        \"tetrahedron\"\n    }\n    parts = [part.strip().lower() for part in re.split(r'[,\\s]+', response.strip()) if part.strip()]\n    if not parts:\n        return False\n    for part in parts:\n        if part not in valid_shapes:\n            return False\n    return True", 1.0]], "cases": [["Triangle", true], ["circle cube", true], ["square, apple", false], ["Circle, square, and triangle", false], ["cube,sphere", true], ["circle", true], ["apple", false], ["circle car", false]]}
{"id": 84, "instruction": "Use only imperative sentences (commands)", "eval_func": [["import re\n\ndef evaluate(response):\n    pronouns = {'you', 'he', 'she', 'they', 'we', 'i', 'it'}\n    question_starts = {'what', 'where', 'when', 'why', 'how', 'who', 'whom', 'whose', 'which', 'can', 'could', 'would', 'will', 'is', 'are', 'do', 'does', 'did'}\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if not sentence:\n            continue\n        words = sentence.lower().split()\n        if not words:\n            continue\n        first_word = words[0]\n        if first_word in question_starts:\n            return False\n        if first_word in pronouns:\n            return False\n        if first_word == 'please':\n            if len(words) < 2:\n                return False\n        elif first_word == 'don\\'t' or (len(words) >=2 and words[0] == 'do' and words[1] == 'not'):\n            if len(words) < 2:\n                return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    pronouns = {'you', 'we', 'i', 'he', 'she', 'they', 'it'}\n    sentences = re.split(r'[.!?]+', response)\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if not sentence:\n            continue\n        first_word = sentence.split()[0].lower()\n        if first_word in pronouns:\n            return False\n    return True", 0.8333333333333334], ["import re\ndef evaluate(response):\n    modals = {'should', 'could', 'would', 'must', 'can', 'may', 'might', 'shall', 'will'}\n    pronouns = {'you', 'we', 'i', 'he', 'she', 'they', 'it'}\n    sentences = re.split(r'[.!?]', response)\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if not sentence:\n            continue\n        words = [word.lower() for word in sentence.split()]\n        if not words:\n            continue\n        if words[0] in pronouns:\n            return False\n        if any(word in modals for word in words):\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    if '?' in response:\n        return False\n    sentences = re.split(r'[.!]', response)\n    subject_pronouns = {'i', 'you', 'he', 'she', 'it', 'we', 'they', 'someone', 'anyone', 'one'}\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if not sentence:\n            continue\n        words = sentence.split()\n        if not words:\n            continue\n        first_word = words[0].lower()\n        if first_word in subject_pronouns:\n            return False\n    return True", 1.0]], "cases": [["Can you help me? Please answer.", false], ["You should turn left.", false], ["Don't stop. Keep moving.", true], ["Please close the door. Lock it.", true], ["Turn left. Walk straight.", true], ["Turn left.", true]]}
{"id": 86, "instruction": "Use only number words (e.g., \"five\" instead of \"5\")", "eval_func": [["import re\ndef evaluate(response):\n    return not re.search(r'\\d', response)", 1.0], ["import re\ndef evaluate(response):\n    return not re.search(r'[0-9]', response)", 1.0], ["def evaluate(response):\n    import re\n    return not re.search(r'\\d', response)", 1.0]], "cases": [["The code is h3ll0.", false], ["She has two sisters.", true], ["She has 2 dogs and one cat.", false], ["He is 25 years old.", false], ["The temperature dropped to -5 degrees.", false], ["I have 5 apples.", false], ["The temperature is minus five degrees.", true], ["There are five apples and three oranges.", true], ["I have five apples and three oranges.", true]]}
{"id": 87, "instruction": "Use only numeric digits (e.g., \"7\" instead of \"seven\")", "eval_func": [["def evaluate(response):\n    return response.isdigit()", 0.9166666666666666], ["import re\ndef evaluate(response):\n    return bool(re.fullmatch(r'^[0-9]+$', response))", 0.9166666666666666], ["def evaluate(response):\n    return all(c in '0123456789' for c in response)", 0.8333333333333334]], "cases": [["12three45", false], ["123", true], ["12three", false], ["She has two cats.", false], ["seven", false], ["7", true], ["7 is a lucky number.", true], ["42", true], ["twelve", false], ["", false], ["The answer is thirty-five.", false], ["123a", false]]}
{"id": 88, "instruction": "Use only past tense verbs ending with \"-ed\"", "eval_func": [["import re\ndef evaluate(response):\n    words = response.split()\n    for word in words:\n        cleaned = re.sub(r'[^a-zA-Z]', '', word).lower()\n        if len(cleaned) < 2 or not cleaned.endswith('ed'):\n            return False\n    return bool(words)", 1.0], ["def evaluate(response):\n    words = response.split()\n    return bool(words) and all(word.endswith('ed') for word in words)", 0.9090909090909091], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if not word.endswith('ed'):\n            return False\n    return True", 0.9090909090909091], ["import string\n\ndef evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        cleaned = word.strip(string.punctuation)\n        if not cleaned:\n            return False\n        if not cleaned.lower().endswith('ed'):\n            return False\n    return True", 1.0]], "cases": [["walked jumped laughed", true], ["jumped danced smiled", true], ["He shouted and rushed", false], ["walked jumped shouted", true], ["he opened the window", false], ["Completed.", true], ["He walked to the store", false], ["singed played run", false], ["shouted and yelled", false], ["landed", true], ["danced", true]]}
{"id": 89, "instruction": "Use only symbols and punctuation (no letters or numbers)", "eval_func": [["import string\n\ndef evaluate(response):\n    return all(c in string.punctuation for c in response)", 1.0], ["def evaluate(response):\n    for c in response:\n        if c.isalnum() or c.isspace():\n            return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    return not re.search('[a-zA-Z0-9]', response)", 0.9], ["def evaluate(response):\n    for char in response:\n        if char.isalnum():\n            return False\n    return True", 0.9]], "cases": [["Hello! 123", false], ["a1!", false], ["No letters but has spaces", false], ["Hello!", false], ["!@#$%", true], ["!@#$%^&*", true], ["@$%^&*()", true], ["   ", false], ["???!!!", true], ["!@#$", true]]}
{"id": 94, "instruction": "Use only words ending with \"-ed\"", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word.endswith('ed'):\n            return False\n    return True", 0.9166666666666666], ["import re\ndef evaluate(response):\n    for word in response.split():\n        processed = re.sub(r'[^a-zA-Z]+$', '', word)\n        if not processed.endswith('ed'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) < 2 or not word.endswith('ed'):\n            return False\n    return True", 0.9166666666666666], ["import re\ndef evaluate(response):\n    for word in response.split():\n        stripped = re.sub(r'[^a-zA-Z]+$', '', word)\n        if not stripped.endswith('ed'):\n            return False\n    return True", 1.0]], "cases": [["Edged shouted", true], ["ran shouted", false], ["walked jumped", true], ["walked excitedly", false], ["started jumped", true], ["jumped hopped", true], ["excited!", true], ["walked talked smiled", true], ["running jumped", false], ["ran and played", false], ["ed", true], ["Ed", false]]}
{"id": 95, "instruction": "Use only words ending with \"-ing\"", "eval_func": [["def evaluate(response):\n    for word in response.split():\n        if not word.endswith('ing'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if len(word) < 3 or not word.endswith('ing'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word.endswith('ing'):\n            return False\n    return True", 1.0]], "cases": [["jumping running", true], ["singing with friends", false], ["jumping running walking", true], ["singing.", false], ["singing dancing running", true], ["hello running", false], ["ING", false], ["singing dancing", true], ["linger", false], ["singing play", false], ["sting", true], ["jumping dancing running", true], ["playing soccer is fun", false], ["loving it", false]]}
{"id": 96, "instruction": "Use only words from the NATO phonetic alphabet", "eval_func": [["def evaluate(response):\n    valid_words = {'alfa', 'bravo', 'charlie', 'delta', 'echo', 'foxtrot', 'golf', 'hotel', 'india', 'juliett', 'kilo', 'lima', 'mike', 'november', 'oscar', 'papa', 'quebec', 'romeo', 'sierra', 'tango', 'uniform', 'victor', 'whiskey', 'x-ray', 'yankee', 'zulu'}\n    words = response.split()\n    for word in words:\n        if word.lower() not in valid_words:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    nato_words = {\n        'Alfa', 'Bravo', 'Charlie', 'Delta', 'Echo', 'Foxtrot',\n        'Golf', 'Hotel', 'India', 'Juliett', 'Kilo', 'Lima', 'Mike',\n        'November', 'Oscar', 'Papa', 'Quebec', 'Romeo', 'Sierra',\n        'Tango', 'Uniform', 'Victor', 'Whiskey', 'X-ray', 'Yankee', 'Zulu'\n    }\n    words = response.split()\n    for word in words:\n        if word not in nato_words:\n            return False\n    return True", 0.9285714285714286], ["def evaluate(response):\n    nato_words = {\n        'alfa', 'bravo', 'charlie', 'delta', 'echo', 'foxtrot',\n        'golf', 'hotel', 'india', 'juliett', 'kilo', 'lima',\n        'mike', 'november', 'oscar', 'papa', 'quebec', 'romeo',\n        'sierra', 'tango', 'uniform', 'victor', 'whiskey',\n        'x-ray', 'yankee', 'zulu'\n    }\n    words = response.split()\n    for word in words:\n        if word.lower() not in nato_words:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    valid_words = {\n        'Alfa', 'Bravo', 'Charlie', 'Delta', 'Echo', 'Foxtrot', 'Golf',\n        'Hotel', 'India', 'Juliett', 'Kilo', 'Lima', 'Mike', 'November',\n        'Oscar', 'Papa', 'Quebec', 'Romeo', 'Sierra', 'Tango', 'Uniform',\n        'Victor', 'Whiskey', 'X-ray', 'Yankee', 'Zulu'\n    }\n    words = response.split()\n    for word in words:\n        if word not in valid_words:\n            return False\n    return True", 0.9285714285714286], ["def evaluate(response):\n    valid_words = {\"Alfa\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\", \"Foxtrot\", \"Golf\", \"Hotel\", \"India\", \"Juliett\", \"Kilo\", \"Lima\", \"Mike\", \"November\", \"Oscar\", \"Papa\", \"Quebec\", \"Romeo\", \"Sierra\", \"Tango\", \"Uniform\", \"Victor\", \"Whiskey\", \"X-ray\", \"Yankee\", \"Zulu\"}\n    words = response.split()\n    for word in words:\n        if word not in valid_words:\n            return False\n    return True", 0.9285714285714286]], "cases": [["Alfa Tango", true], ["X-ray Yankee Zulu", true], ["Alfa", true], ["X-ray", true], ["x-ray yankee", true], ["Alpha X-ray", false], ["Alfa Romeo Tango", true], ["Xray", false], ["Tango Uniform November", true], ["Golf India Alpha", false], ["Golf123 X-Ray", false], ["Alfa Romeo", true], ["Hello World", false], ["Alpha", false]]}
{"id": 97, "instruction": "Use only words from the second half of the alphabet (N-Z)", "eval_func": [["def evaluate(response):\n    for char in response:\n        if char.isalpha():\n            lower_char = char.lower()\n            if lower_char < 'n':\n                return False\n    return True", 1.0], ["def evaluate(response):\n    return all((c.lower() >= 'n' and c.lower() <= 'z') if c.isalpha() else True for c in response)", 1.0], ["def evaluate(response):\n    for char in response:\n        if char.isalpha():\n            upper = char.upper()\n            if upper < 'N' or upper > 'Z':\n                return False\n    return True", 1.0], ["def evaluate(response):\n    for char in response:\n        if char.isalpha() and char.upper() < 'N':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    for char in response:\n        lower_char = char.lower()\n        if 'a' <= lower_char <= 'm':\n            return False\n    return True", 1.0]], "cases": [["NOW", true], ["NOON", true], ["z123#", true], ["123Zoo!", true], ["NZ", true], ["ZYXW", true], ["man", false], ["123Zn", true], ["Nest", false], ["apple", false], ["Z!23", true]]}
{"id": 99, "instruction": "Use only words in the past tense (regular \"-ed\" endings)", "eval_func": [["import string\n\ndef evaluate(response):\n    words = response.split()\n    for word in words:\n        cleaned = word.rstrip(string.punctuation).lower()\n        if not cleaned.endswith('ed'):\n            return False\n    return True", 1.0], ["import string\n\ndef evaluate(response):\n    for word in response.split():\n        processed = word.rstrip(string.punctuation)\n        if len(processed) < 2 or not processed.endswith('ed'):\n            return False\n    return True", 1.0], ["import string\n\ndef evaluate(response):\n    words = response.split()\n    for word in words:\n        stripped_word = word.rstrip(string.punctuation)\n        if len(stripped_word) < 2 or not stripped_word.lower().endswith('ed'):\n            return False\n    return True", 1.0], ["import re\ndef evaluate(response):\n    words = response.split()\n    for word in words:\n        stripped_word = re.sub(r'[^a-zA-Z]+$', '', word)\n        if not stripped_word.endswith('ed'):\n            return False\n    return True", 1.0]], "cases": [["ran walked", false], ["walked talked played", true], ["He asked for help.", false], ["He walked and jumped", false], ["He shouted and waved.", false], ["walked played smiled", true], ["jumped, danced, and shouted", false], ["walked jumped hopped", true], ["Jumped!", true]]}
{"id": 101, "instruction": "Use only words that are abbreviations (e.g., \"ASAP\", \"RSVP\")", "eval_func": [["def evaluate(response):\n    for word in response.split():\n        if len(word) < 2 or not word.isalpha() or not word.isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not (word.isalpha() and word.isupper()):\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    import re\n    for word in response.split():\n        if not re.fullmatch(r'^[A-Z]{2,}$', word):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    words = response.split()\n    if not words:\n        return False\n    pattern = re.compile(r'^[A-Z]{2,}$')\n    for word in words:\n        if not pattern.match(word):\n            return False\n    return True", 1.0]], "cases": [["Meet me ASAP please", false], ["FBI CIA", true], ["Hi there", false], ["FBI CIA NSA", true], ["A BC", false], ["ABC123", false], ["NATO2010", false], ["ASAP RSVP", true], ["Please RSVP", false], ["RSVP now", false], ["FYI that's ASAP", false]]}
{"id": 102, "instruction": "Use only words that are anagrams of the word \"listen\"", "eval_func": [["def evaluate(response):\n    target = sorted(\"listen\")\n    words = response.split()\n    for word in words:\n        if len(word) != 6 or sorted(word.lower()) != target:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    target = sorted('listen')\n    for word in response.split():\n        if sorted(word.lower()) != target:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    target = sorted('listen')\n    words = response.strip().split()\n    for word in words:\n        word_lower = word.lower()\n        if len(word_lower) != 6:\n            return False\n        if sorted(word_lower) != target:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sorted_listen = sorted('listen')\n    for word in response.split():\n        if len(word) != 6:\n            return False\n        if not word.isalpha():\n            return False\n        if sorted(word.lower()) != sorted_listen:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    original_sorted = sorted(\"listen\")\n    words = response.split()\n    for word in words:\n        word_lower = word.lower()\n        if len(word_lower) != 6:\n            return False\n        if sorted(word_lower) != original_sorted:\n            return False\n    return True", 1.0]], "cases": [["listens", false], ["silent listen", true], ["list", false], ["Listen tinsel", true], ["EnLiSt", true], ["listen, tinsel", false], ["TINSEL", true], ["", true], ["hello", false], ["silent", true], ["Silent", true], ["enlist tins", false]]}
{"id": 103, "instruction": "Use only words that are color names", "eval_func": [["def evaluate(response):\n    valid_colors = {'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'rebeccapurple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen'}\n    words = response.split()\n    for word in words:\n        if not word.isalpha() or word.lower() not in valid_colors:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    color_names = {\n        \"red\", \"green\", \"blue\", \"yellow\", \"black\", \"white\", \"orange\", \"purple\",\n        \"pink\", \"brown\", \"gray\", \"cyan\", \"magenta\", \"lavender\", \"lime\", \"maroon\",\n        \"navy\", \"olive\", \"silver\", \"teal\", \"violet\", \"indigo\", \"beige\", \"coral\",\n        \"gold\", \"khaki\", \"salmon\", \"turquoise\", \"crimson\", \"orchid\", \"plum\",\n        \"azure\", \"mint\", \"ivory\", \"tan\", \"chocolate\", \"tomato\", \"firebrick\",\n        \"chartreuse\", \"fuchsia\", \"honeydew\", \"lavenderblush\", \"linen\", \"mistyrose\",\n        \"navajowhite\", \"oldlace\", \"papayawhip\", \"seashell\", \"sienna\", \"thistle\",\n        \"wheat\", \"bisque\", \"darkcyan\", \"deepskyblue\", \"dimgray\", \"dodgerblue\",\n        \"gainsboro\", \"ghostwhite\", \"goldenrod\", \"greenyellow\", \"hotpink\",\n        \"lightblue\", \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\",\n        \"lightgray\", \"lightgreen\", \"lightpink\", \"lightsalmon\", \"lightseagreen\",\n        \"lightskyblue\", \"lightslategray\", \"lightsteelblue\", \"mediumaquamarine\",\n        \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\",\n        \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n        \"mediumvioletred\", \"midnightblue\", \"moccasin\", \"olivedrab\",\n        \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n        \"peachpuff\", \"peru\", \"powderblue\", \"rosybrown\", \"royalblue\",\n        \"saddlebrown\", \"sandybrown\", \"seagreen\", \"skyblue\", \"slateblue\",\n        \"slategray\", \"springgreen\", \"steelblue\", \"thistle\", \"yellowgreen\"\n    }\n    words = response.split()\n    for word in words:\n        if word.lower() not in color_names:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    color_names = {\n        \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\",\n        \"beige\", \"bisque\", \"black\", \"blanchedalmond\", \"blue\",\n        \"blueviolet\", \"brown\", \"burlywood\", \"cadetblue\", \"chartreuse\",\n        \"chocolate\", \"coral\", \"cornflowerblue\", \"cornsilk\", \"crimson\",\n        \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\", \"darkgray\",\n        \"darkgreen\", \"darkgrey\", \"darkkhaki\", \"darkmagenta\",\n        \"darkolivegreen\", \"darkorange\", \"darkorchid\", \"darkred\",\n        \"darksalmon\", \"darkseagreen\", \"darkslateblue\", \"darkslategray\",\n        \"darkslategrey\", \"darkturquoise\", \"darkviolet\", \"deeppink\",\n        \"deepskyblue\", \"dimgray\", \"dimgrey\", \"dodgerblue\", \"firebrick\",\n        \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\",\n        \"ghostwhite\", \"gold\", \"goldenrod\", \"gray\", \"green\", \"greenyellow\",\n        \"honeydew\", \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\",\n        \"lavender\", \"lavenderblush\", \"lawngreen\", \"lemonchiffon\",\n        \"lightblue\", \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\",\n        \"lightgray\", \"lightgreen\", \"lightgrey\", \"lightpink\", \"lightsalmon\",\n        \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightslategrey\",\n        \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\",\n        \"magenta\", \"maroon\", \"mediumaquamarine\", \"mediumblue\",\n        \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\",\n        \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n        \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\",\n        \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\",\n        \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\",\n        \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\",\n        \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"rebeccapurple\",\n        \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\", \"salmon\",\n        \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n        \"slateblue\", \"slategray\", \"slategrey\", \"snow\", \"springgreen\",\n        \"steelblue\", \"tan\", \"teal\", \"thistle\", \"tomato\", \"turquoise\",\n        \"violet\", \"wheat\", \"white\", \"whitesmoke\", \"yellow\", \"yellowgreen\"\n    }\n    words = response.split()\n    for word in words:\n        if word.lower() not in color_names:\n            return False\n    return True", 1.0]], "cases": [["red, blue", false], ["red blue green", true], ["Goldenrod", true], ["purple cat", false], ["apple", false], ["Red", true], ["navy skyblue", true], ["red blue violet", true]]}
{"id": 104, "instruction": "Use only words that are contractions (e.g., \"don't\", \"can't\")", "eval_func": [["def evaluate(response):\n    words = response.split()\n    if not words:\n        return False\n    for word in words:\n        if \"'\" not in word:\n            return False\n    return True", 0.9], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if \"'\" not in word:\n            return False\n    return True", 1.0]], "cases": [["it's a test", false], ["you're right", false], ["shouldn't've", true], ["", true], ["hello", false], ["they'll won't", true], ["hello there", false], ["it is a test", false], ["don't can't", true], ["it's a problem", false]]}
{"id": 105, "instruction": "Use only words that are numbers spelled out (e.g., \"three\", \"seven\")", "eval_func": [["def evaluate(response):\n    valid_numbers = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\", \"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"}\n    words = response.split()\n    for word in words:\n        if word not in valid_numbers:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    valid_numbers = {'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\n                     'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen',\n                     'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen', 'twenty',\n                     'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety',\n                     'hundred', 'thousand', 'million', 'billion', 'trillion'}\n    words = response.strip().split()\n    for word in words:\n        if word.lower() not in valid_numbers:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    allowed = {'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten',\n               'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen',\n               'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'}\n    words = response.strip().split()\n    for word in words:\n        if word.lower() not in allowed:\n            return False\n    return True", 1.0]], "cases": [["five apples", false], ["twenty-one", false], ["twenty one", true], ["three seven", true]]}
{"id": 107, "instruction": "Use only words that are palindromes and have four letters", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) != 4:\n            return False\n        if word != word[::-1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) !=4 or not word.isalpha() or word != word[::-1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) !=4 or word != word[::-1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) != 4 or word != word[::-1]:\n            return False\n    return True", 1.0]], "cases": [["abba test", false], ["abba peep", true], ["abba aaaa", true], ["abba de", false], ["", true], ["abba deed", true], ["abca", false], ["abba abax", false]]}
{"id": 108, "instruction": "Use only words that are proper nouns", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word:\n            continue\n        if not word[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word or not word[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        first_alpha = next((c for c in word if c.isalpha()), None)\n        if not first_alpha or not first_alpha.isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    for word in response.split():\n        if not word[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    return all(word and word[0].isupper() for word in response.split())", 1.0]], "cases": [["Paris London Tokyo", true], ["Mount Everest", true], ["Paris NewYork NASA", true], ["Paris London", true], ["Paris France", true], ["paris France", false], ["apple Microsoft", false], ["", true], ["paris London", false], ["apple Pie", false], ["New York City 123", false], ["Tokyo 2020", false], ["apple", false]]}
{"id": 109, "instruction": "Use only words that can be typed with the left hand on a QWERTY keyboard", "eval_func": [["def evaluate(response):\n    allowed = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    for char in response:\n        if char.lower() not in allowed:\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    left_hand_letters = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    allowed_numbers = {'1', '2', '3', '4', '5'}\n    allowed_symbols = {'`', '~', '!', '@', '#', '$', '%'}\n    allowed_whitespace = {' '}\n    for char in response:\n        lower_char = char.lower()\n        if lower_char in left_hand_letters:\n            continue\n        elif char in allowed_numbers:\n            continue\n        elif char in allowed_symbols:\n            continue\n        elif char in allowed_whitespace:\n            continue\n        else:\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    allowed = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    for char in response:\n        if not char.isalpha():\n            return False\n        if char.lower() not in allowed:\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    allowed = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    for char in response:\n        if not char.isalpha() or char.lower() not in allowed:\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    allowed = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    for char in response:\n        lower_char = char.lower()\n        if not lower_char.isalpha():\n            return False\n        if lower_char not in allowed:\n            return False\n    return True", 0.9090909090909091]], "cases": [["SWEATER", true], ["assert", true], ["water! 123$%", true], ["test test", false], ["Weaver", true], ["RESTART", true], ["Gazer", true], ["Hello", false], ["zest fog", false], ["CvB", true], ["redder", true]]}
{"id": 111, "instruction": "Use only words that contain the letter 'Q'", "eval_func": [["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if 'q' not in word.lower():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    for word in response.split():\n        if 'q' not in word.lower():\n            return False\n    return True", 1.0]], "cases": [["Quiet quilt", true], ["Squid qat", true], ["Queen Quail Squeeze", true], ["Apple Banana", false], ["Apple Queen Banana", false], ["q QQE", true], ["squash qat", true], ["Quiet Quest", true], ["Apple Queen", false]]}
{"id": 112, "instruction": "Use only words that end with 'ed'", "eval_func": [["def evaluate(response):\n    import re\n    words = response.split()\n    for word in words:\n        processed_word = re.sub(r'[^a-zA-Z]+$', '', word)\n        if not processed_word.lower().endswith('ed'):\n            return False\n    return True", 0.9285714285714286], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if not word.endswith('ed'):\n            return False\n    return True", 0.8571428571428571], ["def evaluate(response):\n    for word in response.split():\n        if not word.endswith('ed'):\n            return False\n    return True", 0.8571428571428571], ["import re\n\ndef evaluate(response):\n    for word in response.split():\n        processed = re.sub(r'[^a-zA-Z]+$', '', word)\n        if not processed.endswith('ed'):\n            return False\n    return True", 0.9285714285714286]], "cases": [["walked jumped", true], ["jumped run", false], ["He walked fast", false], ["jumped hopped", true], ["walked talked", true], ["The cat jumped", false], ["jumped!", true], ["hated, excited", true], ["Burned, but not charred", false], ["jumped walked", true], ["ran quickly", false], ["hated.", false], ["jumped and ran", false], ["hiked played", true]]}
{"id": 113, "instruction": "Use only words that start with the letter 'W'", "eval_func": [["def evaluate(response):\n    for word in response.split():\n        if word[0].upper() != 'W':\n            return False\n    return True", 0.8], ["def evaluate(response):\n    return all(word.lower().startswith('w') for word in response.split())", 0.8], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) == 0:\n            continue\n        if word[0].lower() != 'w':\n            return False\n    return True", 0.8]], "cases": [["warm winter wishes", true], ["Wendy walked west", true], ["Where's Waldo?", true], ["wonderful weather", false], ["Winter winds whip wildly.", true], ["world", true], ["Warm winters welcome wanderers", false], ["Warm water", false], ["Winter is coming", false], ["Wendy walks with wolves", true], ["Warm wishes wonderfully", true], ["Hello world", false], ["wAlk Walk wander", true], ["Walnuts and water", false], ["Sunset whispers", false]]}
{"id": 114, "instruction": "Use only words typable with the left hand on a QWERTY keyboard", "eval_func": [["def evaluate(response):\n    allowed = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    for char in response:\n        if char.isalpha():\n            if char.lower() not in allowed:\n                return False\n    return True", 0.8461538461538461], ["def evaluate(response):\n    allowed = {'q','w','e','r','t','a','s','d','f','g','z','x','c','v','b'}\n    for char in response.lower():\n        if not char.isalpha():\n            return False\n        if char not in allowed:\n            return False\n    return True", 0.8461538461538461], ["def evaluate(response):\n    allowed = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    return all(c in allowed for c in response.lower())", 0.8461538461538461], ["def evaluate(response):\n    allowed = {'q', 'w', 'e', 'r', 't', 'a', 's', 'd', 'f', 'g', 'z', 'x', 'c', 'v', 'b'}\n    for char in response:\n        if not char.isalpha():\n            return False\n        if char.lower() not in allowed:\n            return False\n    return True", 0.8461538461538461]], "cases": [["test", true], ["z3bra", false], ["water5", false], ["swear", true], ["after", true], ["moon", false], ["Gazer", true], ["Hello", false], ["Crab123!", true], ["Test123!", true], ["Test", true], ["red", true], ["Python", false]]}
{"id": 115, "instruction": "Use only words with ascending alphabetical order (e.g., \"abc\")", "eval_func": [["def evaluate(response):\n    for word in response.split():\n        for i in range(len(word) - 1):\n            if word[i] >= word[i+1]:\n                return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        for i in range(len(word) - 1):\n            if word[i] >= word[i + 1]:\n                return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        for i in range(len(word) - 1):\n            if word[i] >= word[i+1]:\n                return False\n    return True", 1.0]], "cases": [["a bc defgh", true], ["a bc def xyz", true], ["abba", false], ["acb", false], ["", true], ["a bc xyz", true], ["abc", true]]}
{"id": 117, "instruction": "Use only words with exactly four letters", "eval_func": [["def evaluate(response):\n    for word in response.split():\n        if len(word) != 4:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) != 4 or not word.isalpha():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    words = response.split()\n    for word in words:\n        if len(word) != 4:\n            return False\n    return True", 1.0]], "cases": [["Word four test okay", true], ["Four word true", true], ["This is true", false], ["Hey there", false], ["Five fingers", false], ["don't", false], ["", true], ["don't stop", false], ["Test okay", true], ["This test good", true], ["Hello world", false]]}
{"id": 119, "instruction": "Use past continuous tense verbs (e.g., \"was running\")", "eval_func": [["import re\n\ndef evaluate(response):\n    return re.search(r'\\b(was|were)\\b.*?\\b\\w+ing\\b', response, re.IGNORECASE) is not None", 1.0], ["def evaluate(response):\n    words = response.lower().split()\n    for i in range(1, len(words)):\n        if words[i-1] in {'was', 'were'} and words[i].endswith('ing'):\n            return True\n    return False", 1.0], ["import re\n\ndef evaluate(response):\n    return bool(re.search(r'\\b(was|were)\\b.*?\\b\\w+ing\\b', response, flags=re.IGNORECASE))", 1.0], ["import re\n\ndef evaluate(response):\n    past_continuous = re.search(r'\\b(was|were)\\b.*?\\b\\w+ing\\b', response, re.IGNORECASE)\n    present_continuous = re.search(r'\\b(am|is|are)\\b.*?\\b\\w+ing\\b', response, re.IGNORECASE)\n    return bool(past_continuous) and not bool(present_continuous)", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r'\\b(was|were)(\\s+\\w+)*\\s+\\w+ing\\b'\n    return bool(re.search(pattern, response, re.IGNORECASE))", 1.0]], "cases": [["She wrote a letter.", false], ["They were singing loudly.", true], ["He ate dinner quickly.", false], ["He was swimming in the pool.", true], ["He is running in the park.", false], ["She was singing while he was dancing.", true], ["They played football.", false], ["They were laughing loudly.", true], ["She was reading a book.", true]]}
{"id": 121, "instruction": "Use past perfect tense verbs (e.g., \"had finished\")", "eval_func": [["import re\n\ndef evaluate(response):\n    irregular_past_participles = {\n        'been', 'gone', 'eaten', 'written', 'taken', 'seen', 'done',\n        'made', 'found', 'given', 'come', 'known', 'said', 'left', 'put',\n        'begun', 'brought', 'broken', 'chosen', 'driven', 'fallen', 'flown',\n        'forgotten', 'hidden', 'ridden', 'risen', 'sung', 'spoken', 'stolen',\n        'swum', 'torn', 'thrown', 'woken', 'worn', 'woven'\n    }\n    text = re.sub(r'[^\\w\\s]', '', response.lower())\n    words = text.split()\n    for i in range(len(words) - 1):\n        if words[i] == 'had':\n            next_word = words[i+1]\n            if next_word.endswith('ed') or next_word in irregular_past_participles:\n                return True\n    return False", 1.0], ["def evaluate(response):\n    irregular_past_participles = {\n        'been', 'gone', 'eaten', 'written', 'seen', 'driven', 'taken', 'given',\n        'spoken', 'broken', 'chosen', 'fallen', 'flown', 'known', 'ridden', 'sung',\n        'swum', 'thrown', 'worn', 'begun', 'drunk', 'rung', 'sunk', 'stolen', 'torn',\n        'woken', 'brought', 'bought', 'caught', 'fought', 'thought', 'sold', 'told',\n        'found', 'held', 'kept', 'left', 'lost', 'made', 'met', 'read',\n        'said', 'sent', 'shut', 'sat', 'slept', 'spent', 'stood', 'understood',\n        'won', 'got', 'forgotten', 'hidden', 'hit', 'hurt', 'let', 'put', 'quit',\n        'set', 'spread', 'upset', 'beat', 'become', 'come', 'run', 'shaken', 'shone',\n        'shot', 'slid', 'stuck', 'struck', 'swept', 'wept', 'arisen', 'awoken',\n        'lain', 'lied', 'lit', 'risen', 'shaved', 'shorn', 'shown',\n        'shrunk', 'sown', 'spat', 'split', 'spoiled', 'spoilt', 'sprung', 'stunk',\n        'strived', 'strove', 'sworn', 'thrived', 'throve', 'wound', 'wrung'\n    }\n    words = response.lower().split()\n    for i in range(len(words) - 1):\n        current_word = words[i].rstrip('.,?!')\n        if current_word == 'had':\n            next_word = words[i + 1].rstrip('.,?!')\n            if next_word.endswith('ed') or next_word in irregular_past_participles:\n                return True\n    return False", 1.0]], "cases": [["He had gone to the park.", true], ["I had a car.", false], ["They had eat dinner.", false], ["He had gone to the store.", true], ["She had completed her work.", true], ["She had finished her homework.", true]]}
{"id": 122, "instruction": "Use perfect tense verbs (e.g., \"have eaten\")", "eval_func": [["def evaluate(response):\n    irregular_pps = {'been', 'eaten', 'gone', 'written', 'taken', 'broken', 'chosen', 'driven', 'spoken', 'ridden', 'given', 'seen', 'done', 'had', 'made', 'found', 'left', 'known', 'put', 'read', 'said', 'sat', 'stood', 'swum', 'thrown', 'woken', 'worn', 'brought', 'bought', 'caught', 'taught', 'thought', 'slept', 'swept', 'kept', 'wept', 'crept', 'felt', 'dealt', 'built'}\n    words = response.lower().split()\n    for i in range(len(words) - 1):\n        if words[i] in {'have', 'has', 'had'}:\n            next_word = words[i+1]\n            if next_word in irregular_pps or next_word.endswith('ed'):\n                return True\n    return False", 1.0], ["import re\n\ndef evaluate(response):\n    past_participles = {'eaten', 'gone', 'written', 'been', 'done', 'seen', 'taken', 'given', 'made', 'come', 'run', 'spoken', 'had'}\n    pattern = re.compile(r'\\b(have|has|had)\\s+(\\w+)', re.IGNORECASE)\n    matches = pattern.findall(response)\n    for aux, verb in matches:\n        if verb.lower().endswith('ed') or verb.lower() in past_participles:\n            return True\n    return False", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r'\\b(has|have|had|will have)\\s+(\\w+ed|eaten|gone|written|seen|been|done|taken|spoken|driven|given|known|made|put|read|said|sold|sent|sung|slept|stood|swum|told|thrown|worn|won)\\b'\n    return bool(re.search(pattern, response, re.IGNORECASE))", 1.0], ["def evaluate(response):\n    irregular_pp = {'eaten', 'written', 'gone', 'been', 'seen', 'taken', 'given', 'done', 'made', 'found', 'had', 'sung', 'driven', 'known', 'chosen'}\n    words = response.lower().split()\n    for i in range(len(words) - 1):\n        if words[i] in {'have', 'has', 'had'}:\n            next_word = words[i+1]\n            if next_word.endswith(('ed', 'en')) or next_word in irregular_pp:\n                return True\n    return False", 1.0]], "cases": [["She has written the report.", true], ["I have finished my work.", true], ["They had a meeting yesterday.", false]]}
{"id": 123, "instruction": "Use pluperfect tense verbs (e.g., \"had spoken\")", "eval_func": [["import re\n\ndef evaluate(response):\n    irregular_past_participles = {\n        'spoken', 'eaten', 'gone', 'written', 'done', 'seen',\n        'been', 'driven', 'given', 'taken', 'broken', 'chosen',\n        'fallen', 'known', 'ridden', 'sworn', 'thrown', 'worn',\n        'begun', 'bitten', 'blown', 'drawn', 'flown', 'frozen',\n        'hidden', 'risen', 'shaken', 'shrunk', 'sprung', 'stolen',\n        'torn', 'woven'\n    }\n    matches = re.finditer(r'\\bhad\\s+(\\w+)\\b', response, re.IGNORECASE)\n    for match in matches:\n        verb = match.group(1).lower()\n        if verb.endswith('ed') or verb in irregular_past_participles:\n            return True\n    return False", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    irregular_pp = {\n        'spoken', 'eaten', 'written', 'gone', 'seen', 'taken', 'given',\n        'driven', 'begun', 'rung', 'swum', 'sung', 'sunk', 'brought',\n        'bought', 'caught', 'chosen', 'done', 'fallen', 'flown', 'known',\n        'ridden', 'risen', 'run', 'sworn', 'thrown', 'worn', 'broken', 'drawn',\n        'grown', 'shaken', 'stolen', 'torn', 'woken', 'been', 'held',\n        'left', 'made', 'paid', 'said', 'sent', 'slept', 'stood', 'won', 'got'\n    }\n    pp_regex = r'(?:' + '|'.join(irregular_pp) + r'|\\w+ed)'\n    pattern = re.compile(r'\\bhad\\b\\s+(?:\\w+\\s+)*?' + pp_regex + r'\\b', re.IGNORECASE)\n    return bool(pattern.search(response))", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    irregular_pp = {'been', 'spoken', 'written', 'gone', 'seen', 'eaten', 'taken', 'given', 'done', 'made', 'come', 'swum', 'sung', 'driven', 'ridden', 'thrown', 'known', 'chosen', 'broken', 'worn', 'torn', 'begun', 'drunk', 'sunk', 'shrunk', 'stolen', 'woven', 'frozen', 'hidden', 'beaten', 'bitten', 'forgotten', 'gotten', 'risen', 'shaken', 'slain', 'sought', 'sold', 'sent', 'slept', 'smitten', 'sown', 'spat', 'sped', 'spent', 'spun', 'spit', 'split', 'spread', 'sprung', 'stood', 'stuck', 'stung', 'stunk', 'stridden', 'struck', 'strung', 'strove', 'submitted', 'sworn', 'swept', 'swollen', 'swung', 'taught', 'told', 'thought', 'thrived', 'thrust', 'trodden', 'understood', 'upset', 'woken', 'woven', 'wept', 'wet', 'won', 'wound', 'withdrawn', 'withheld', 'withstood', 'wrung', 'written'}\n    words = re.findall(r'\\b\\w+\\b', response.lower())\n    for i in range(len(words) - 1):\n        if words[i] == 'had':\n            next_word = words[i+1]\n            if next_word.endswith('ed') or next_word in irregular_pp:\n                return True\n    return False", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    irregular_past_participles = {'been', 'become', 'begun', 'bent', 'bet', 'bitten', 'blown', 'broken', 'brought', 'built', 'bought', 'caught', 'chosen', 'come', 'cut', 'done', 'drawn', 'drunk', 'driven', 'eaten', 'fallen', 'felt', 'fought', 'found', 'flown', 'forgotten', 'forgiven', 'frozen', 'gotten', 'given', 'gone', 'grown', 'hung', 'heard', 'hidden', 'hit', 'held', 'hurt', 'kept', 'known', 'laid', 'led', 'left', 'lent', 'let', 'lain', 'lost', 'made', 'meant', 'met', 'paid', 'put', 'read', 'ridden', 'rung', 'risen', 'run', 'said', 'seen', 'sold', 'sent', 'set', 'shaken', 'shone', 'shot', 'shown', 'shut', 'sung', 'sunk', 'sat', 'slept', 'spoken', 'spent', 'stood', 'stolen', 'stuck', 'stung', 'stunk', 'sworn', 'swept', 'swum', 'taken', 'taught', 'torn', 'told', 'thought', 'thrown', 'understood', 'upset', 'worn', 'woken', 'won', 'withdrawn', 'written'}\n    words = re.findall(r\"\\b[\\w']+\\b\", response.lower())\n    for i in range(len(words) - 1):\n        if words[i] == 'had':\n            next_word = words[i+1]\n            if next_word.endswith('ed') or next_word in irregular_past_participles:\n                return True\n    return False", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    lower_response = response.lower()\n    words = [re.sub(r'^\\W+|\\W+$', '', word) for word in lower_response.split()]\n    irregular_pp = {'spoken', 'written', 'eaten', 'gone', 'been', 'done', 'seen',\n                    'made', 'taken', 'given', 'come', 'begun', 'drunk', 'driven',\n                    'flown', 'known', 'ridden', 'rung', 'sung', 'sunk', 'swum'}\n    for i in range(len(words) - 1):\n        if words[i] == 'had':\n            next_word = words[i + 1]\n            if next_word.endswith('ed') or next_word in irregular_pp:\n                return True\n    return False", 0.8333333333333334]], "cases": [["They have finished the work.", false], ["He had a book and walked to the park.", false], ["She had spoken to him before the meeting started.", true], ["They had quickly eaten all the snacks.", true], ["He had walked home when it started raining.", true], ["She had spoken to him before leaving.", true]]}
{"id": 124, "instruction": "Use present perfect continuous tense verbs (e.g., \"has been waiting\")", "eval_func": [["import re\n\ndef evaluate(response):\n    pattern = r\"\\b(has|have|\\w+'s|\\w+'ve)\\s+been\\b.*?\\b\\w+ing\\b\"\n    return bool(re.search(pattern, response, flags=re.IGNORECASE))", 1.0]], "cases": [["He has been waiting for an hour.", true], ["They've been working on the project.", true], ["She is running late.", false]]}
{"id": 125, "instruction": "Use present perfect tense verbs (e.g., \"has written\")", "eval_func": [["import re\n\ndef evaluate(response):\n    irregular_pp = r'(written|gone|seen|been|done|spoken|eaten|driven|given|known)'\n    pattern = re.compile(r'\\b(has|have)\\s+(\\w+ed\\b|' + irregular_pp + r')\\b', re.IGNORECASE)\n    return bool(pattern.search(response))", 1.0], ["import re\n\ndef evaluate(response):\n    if re.search(r'\\b(has|have)\\s+\\w+ed\\b', response, re.IGNORECASE):\n        return True\n    irregulars = {'been', 'written', 'eaten', 'gone', 'done', 'seen', 'made', 'taken', 'given', 'had', 'come', 'become', 'begun', 'sung', 'sunk', 'driven', 'ridden', 'spoken', 'broken', 'chosen', 'fallen', 'forgotten', 'frozen', 'stolen', 'torn', 'worn'}\n    words = response.lower().split()\n    for i in range(len(words) - 1):\n        if words[i] in ['has', 'have'] and words[i+1] in irregulars:\n            return True\n    return False", 1.0], ["import re\n\ndef evaluate(response):\n    common_irregulars = r'(written|done|seen|gone|been|had|made|known|taken|given|eaten|spoken)'\n    pattern = re.compile(r'\\b(has|have)\\s+(' + common_irregulars + r'|\\w+ed)\\b', re.IGNORECASE)\n    return bool(pattern.search(response))", 1.0], ["import re\ndef evaluate(response):\n    return re.search(r'\\b(has|have)\\s+\\w+', response, re.IGNORECASE) is not None", 1.0], ["def evaluate(response):\n    irregular_pps = {\n        'been', 'gone', 'seen', 'written', 'eaten', 'taken', 'given', 'driven',\n        'spoken', 'broken', 'chosen', 'done', 'had', 'made', 'known', 'found',\n        'come', 'become', 'begun', 'sung', 'sunk', 'rung', 'swum', 'ridden',\n        'thrown', 'blown', 'drawn', 'grown', 'flown', 'arisen', 'awoken',\n        'beaten', 'bitten', 'hidden', 'forgotten', 'forgiven', 'frozen',\n        'gotten', 'shaken', 'shone', 'shot', 'slid', 'sought', 'sold', 'sent',\n        'slept', 'spent', 'stood', 'stolen', 'stuck', 'stung', 'swept',\n        'sworn', 'taught', 'torn', 'told', 'thought', 'understood', 'woken',\n        'worn', 'won', 'withdrawn', 'wrung', 'left', 'lost', 'met', 'paid',\n        'said', 'sat', 'slept', 'slain', 'held', 'kept', 'laid', 'led', 'lit',\n        'risen', 'run', 'shaken', 'shrunk', 'sung', 'sunk', 'sat', 'slid'\n    }\n    words = response.lower().split()\n    for i in range(len(words)):\n        if words[i] in ['has', 'have']:\n            for j in range(i + 1, len(words)):\n                word = words[j]\n                if word.endswith('ed') or word in irregular_pps:\n                    return True\n    return False", 1.0]], "cases": [["She has written a book.", true], ["They have played football.", true], ["He wrote a letter.", false]]}
{"id": 127, "instruction": "Use subjunctive mood markers (e.g., \"suggest,\" \"demand\")", "eval_func": [["import string\ndef evaluate(response):\n    markers = {'suggest', 'demand', 'recommend', 'insist', 'propose', 'request', 'urge', 'ask', 'require', 'advise', 'command'}\n    for word in response.split():\n        cleaned = word.strip(string.punctuation).lower()\n        if cleaned in markers:\n            return True\n    return False", 1.0], ["import re\n\ndef evaluate(response):\n    markers = [\"suggest\", \"demand\", \"recommend\", \"insist\", \"request\", \"propose\", \"order\", \"ask\", \"require\", \"urge\"]\n    pattern = r'\\b(' + '|'.join(markers) + r')\\b'\n    return bool(re.search(pattern, response, flags=re.IGNORECASE))", 1.0], ["import re\n\ndef evaluate(response):\n    markers = {'suggest', 'demand', 'insist', 'propose', 'recommend', 'request', 'urge', 'require', 'ask', 'advise'}\n    words = re.findall(r'\\b\\w+\\b', response.lower())\n    return any(word in markers for word in words)", 1.0], ["import re\n\ndef evaluate(response):\n    markers = {'suggest', 'demand', 'insist', 'recommend', 'request', 'propose', 'urge', 'command', 'order', 'ask', 'advise', 'require'}\n    pattern = r'\\b(' + '|'.join(re.escape(marker) for marker in markers) + r')\\b'\n    return bool(re.search(pattern, response, re.IGNORECASE))", 1.0]], "cases": [["I suggest that he arrive early.", true], ["She demanded an answer immediately.", false]]}
{"id": 128, "instruction": "Write each sentence as a question and an exclamation alternately", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = re.findall(r'[^!?]*[!?]', response)\n    punctuations = []\n    for sentence in sentences:\n        stripped = sentence.strip()\n        if len(stripped) == 0:\n            return False\n        last_char = stripped[-1]\n        if last_char not in ('?', '!'):\n            return False\n        punctuations.append(last_char)\n    if not punctuations:\n        return False\n    for i in range(1, len(punctuations)):\n        if punctuations[i] == punctuations[i-1]:\n            return False\n    return True", 0.8888888888888888], ["def evaluate(response):\n    import re\n    sentences = re.findall(r'[^!?]*[!?]', response.strip())\n    types = []\n    for sent in sentences:\n        sent_stripped = sent.strip()\n        if not sent_stripped:\n            return False\n        last_char = sent_stripped[-1]\n        if last_char not in ('?', '!'):\n            return False\n        types.append(last_char)\n    if not types:\n        return False\n    prev = types[0]\n    for i in range(1, len(types)):\n        if types[i] == prev:\n            return False\n        prev = types[i]\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    sentences = re.findall(r'[^!?]*[!?]', response)\n    if not sentences:\n        return False\n    if ''.join(sentences) != response:\n        return False\n    prev_type = None\n    for sentence in sentences:\n        if sentence.endswith('?'):\n            current_type = 'question'\n        else:\n            current_type = 'exclamation'\n        if prev_type is not None and current_type == prev_type:\n            return False\n        prev_type = current_type\n    return True", 0.8888888888888888], ["import re\n\ndef evaluate(response):\n    sentences = re.findall(r'[^!?]*[!?]', response)\n    if ''.join(sentences) != response:\n        return False\n    if not sentences:\n        return False\n    prev = sentences[0][-1]\n    for sentence in sentences[1:]:\n        current = sentence[-1]\n        if current == prev:\n            return False\n        prev = current\n    return True", 0.8888888888888888]], "cases": [["Hi! How are you! Great?", false], ["Wow! How's it going? Great!", true], ["Wow! That's awesome. Are you sure?", false], ["Is it raining? That's awesome! Are you sure?", true], ["Wow! How did you do that? Amazing!", true], ["How's the weather? It's sunny today!", true], ["Hello? Yes! No?", true], ["Hi? How are you? Not bad!", false], ["This is a question? This is also a question?", false]]}
{"id": 133, "instruction": "Write the response in binary code (0s and 1s only)", "eval_func": [["import re\ndef evaluate(response):\n    return re.fullmatch(r'^[01]+$', response) is not None", 0.8571428571428571], ["def evaluate(response):\n    return len(response) > 0 and all(c in '01' for c in response)", 0.8571428571428571], ["def evaluate(response):\n    return bool(response) and all(c in '01' for c in response)", 0.8571428571428571], ["import re\n\ndef evaluate(response):\n    return bool(re.fullmatch(r'^[01]+$', response))", 0.8571428571428571], ["def evaluate(response):\n    return all(c in {'0', '1'} for c in response)", 0.8571428571428571]], "cases": [["0101", true], ["0b1010", false], ["010101", true], ["", true], ["0210", false], ["", false], ["02101", false]]}
{"id": 134, "instruction": "Write the response in hexadecimal code", "eval_func": [["def evaluate(response):\n    import string\n    return len(response) > 0 and all(c in string.hexdigits for c in response)", 1.0], ["import string\n\ndef evaluate(response):\n    return len(response) > 0 and all(c in string.hexdigits for c in response)", 1.0], ["import re\n\ndef evaluate(response):\n    return bool(re.fullmatch(r'^[0-9A-Fa-f]+$', response))", 1.0], ["import re\n\ndef evaluate(response):\n    return bool(re.fullmatch(r'^[0-9a-fA-F]+$', response))", 1.0]], "cases": [["A1B2", true], ["0x1a3f", false], ["deadbeef", true], ["1a3f", true], ["1a3B", true], ["123XYZ", false], ["", false], ["1g3f", false], ["ghijkl", false]]}
{"id": 135, "instruction": "Write the response in reverse sentence order (last sentence first)", "eval_func": [["import re\n\ndef evaluate(response):\n    sentences = re.split(r'(?<=[.!?])\\s+', response.strip())\n    if len(sentences) <= 1:\n        return True\n    reversed_sentences = sentences[::-1]\n    return ' '.join(reversed_sentences) == response", 1.0]], "cases": [["First. Third. First.", true], ["Hello world. This is a test.", false], ["Only one sentence.", true], ["Third. Second. First.", false], ["A. B. A.", true]]}
{"id": 136, "instruction": "Write the response using Morse code separated by slashes (e.g., \".-/...\")", "eval_func": [["def evaluate(response):\n    allowed_chars = {'/', '.', '-'}\n    for c in response:\n        if c not in allowed_chars:\n            return False\n    parts = response.split('/')\n    if not parts:\n        return False\n    for part in parts:\n        if not part:\n            return False\n        for c in part:\n            if c not in {'.', '-'}:\n                return False\n    return True", 1.0], ["def evaluate(response):\n    parts = response.split('/')\n    for part in parts:\n        if not part:\n            return False\n        if any(c not in '.-' for c in part):\n            return False\n    return bool(parts)", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n    parts = response.split('/')\n    for part in parts:\n        if not part:\n            return False\n        for c in part:\n            if c not in '.-':\n                return False\n    return True", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n    parts = response.split('/')\n    if any(part == '' for part in parts):\n        return False\n    for part in parts:\n        if not all(c in '.-' for c in part):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    segments = response.split('/')\n    for seg in segments:\n        if not seg:\n            return False\n        if not all(c in '.-' for c in seg):\n            return False\n    return True", 1.0]], "cases": [[".-/...", true], ["..../", false], ["hello", false]]}
{"id": 138, "instruction": "Write the response using only punctuation marks", "eval_func": [["import string\n\ndef evaluate(response):\n    return all(c in string.punctuation for c in response)", 1.0], ["import string\ndef evaluate(response):\n    return all(c in string.punctuation for c in response)", 1.0], ["import string\n\ndef evaluate(response):\n    allowed = set(string.punctuation)\n    for char in response:\n        if char not in allowed:\n            return False\n    return True", 1.0]], "cases": [[" ,", false], ["Hello!", false], ["!?", true]]}
{"id": 139, "instruction": "Write the response without any vowels (A, E, I, O, U)", "eval_func": [["def evaluate(response):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'}\n    return all(c not in vowels for c in response)", 1.0], ["def evaluate(response):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    for char in response:\n        if char.lower() in vowels:\n            return False\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    return not re.search(r'[AEIOUaeiou]', response)", 1.0]], "cases": [["python", false], ["rhythm", true], ["Rhythm", true], ["AEIOUaeiou", false], ["", true], ["hello", false], ["Hello", false], ["AEIOU", false], ["xyz", true], ["BCDFG", true]]}
{"id": 141, "instruction": "Write the response without using the letter 'A'", "eval_func": [["def evaluate(response):\n    return 'a' not in response.lower()", 0.9090909090909091], ["def evaluate(response):\n    return 'A' not in response.upper()", 0.9090909090909091]], "cases": [["123Aa!", false], ["A quick fox", false], ["Hello World", true], ["Butterfly", true], ["banana", false], ["Hello World!", true], ["An apple a day", false], ["banana split", true], ["apple", false], ["Apple", false], ["Banana", false]]}
